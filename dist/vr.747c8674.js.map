{"mappings":"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","sources":["node_modules/three/examples/jsm/webxr/VRButton.js","node_modules/three/examples/jsm/loaders/GLTFLoader.js","node_modules/three/examples/jsm/libs/motion-controllers.module.js","node_modules/three/examples/jsm/webxr/XRControllerModelFactory.js","example/lib/MaterialReducer.js","node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","example/lib/ProxyBatchedMesh.js","example/vr.js"],"sourcesContent":["class VRButton {\n\n\tstatic createButton( renderer, options ) {\n\n\t\tif ( options ) {\n\n\t\t\tconsole.error( 'THREE.VRButton: The \"options\" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.' );\n\n\t\t}\n\n\t\tconst button = document.createElement( 'button' );\n\n\t\tfunction showEnterVR( /*device*/ ) {\n\n\t\t\tlet currentSession = null;\n\n\t\t\tasync function onSessionStarted( session ) {\n\n\t\t\t\tsession.addEventListener( 'end', onSessionEnded );\n\n\t\t\t\tawait renderer.xr.setSession( session );\n\t\t\t\tbutton.textContent = 'EXIT VR';\n\n\t\t\t\tcurrentSession = session;\n\n\t\t\t}\n\n\t\t\tfunction onSessionEnded( /*event*/ ) {\n\n\t\t\t\tcurrentSession.removeEventListener( 'end', onSessionEnded );\n\n\t\t\t\tbutton.textContent = 'ENTER VR';\n\n\t\t\t\tcurrentSession = null;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tbutton.style.display = '';\n\n\t\t\tbutton.style.cursor = 'pointer';\n\t\t\tbutton.style.left = 'calc(50% - 50px)';\n\t\t\tbutton.style.width = '100px';\n\n\t\t\tbutton.textContent = 'ENTER VR';\n\n\t\t\tbutton.onmouseenter = function () {\n\n\t\t\t\tbutton.style.opacity = '1.0';\n\n\t\t\t};\n\n\t\t\tbutton.onmouseleave = function () {\n\n\t\t\t\tbutton.style.opacity = '0.5';\n\n\t\t\t};\n\n\t\t\tbutton.onclick = function () {\n\n\t\t\t\tif ( currentSession === null ) {\n\n\t\t\t\t\t// WebXR's requestReferenceSpace only works if the corresponding feature\n\t\t\t\t\t// was requested at session creation time. For simplicity, just ask for\n\t\t\t\t\t// the interesting ones as optional features, but be aware that the\n\t\t\t\t\t// requestReferenceSpace call will fail if it turns out to be unavailable.\n\t\t\t\t\t// ('local' is always available for immersive sessions and doesn't need to\n\t\t\t\t\t// be requested separately.)\n\n\t\t\t\t\tconst sessionInit = { optionalFeatures: [ 'local-floor', 'bounded-floor', 'hand-tracking', 'layers' ] };\n\t\t\t\t\tnavigator.xr.requestSession( 'immersive-vr', sessionInit ).then( onSessionStarted );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentSession.end();\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction disableButton() {\n\n\t\t\tbutton.style.display = '';\n\n\t\t\tbutton.style.cursor = 'auto';\n\t\t\tbutton.style.left = 'calc(50% - 75px)';\n\t\t\tbutton.style.width = '150px';\n\n\t\t\tbutton.onmouseenter = null;\n\t\t\tbutton.onmouseleave = null;\n\n\t\t\tbutton.onclick = null;\n\n\t\t}\n\n\t\tfunction showWebXRNotFound() {\n\n\t\t\tdisableButton();\n\n\t\t\tbutton.textContent = 'VR NOT SUPPORTED';\n\n\t\t}\n\n\t\tfunction showVRNotAllowed( exception ) {\n\n\t\t\tdisableButton();\n\n\t\t\tconsole.warn( 'Exception when trying to call xr.isSessionSupported', exception );\n\n\t\t\tbutton.textContent = 'VR NOT ALLOWED';\n\n\t\t}\n\n\t\tfunction stylizeElement( element ) {\n\n\t\t\telement.style.position = 'absolute';\n\t\t\telement.style.bottom = '20px';\n\t\t\telement.style.padding = '12px 6px';\n\t\t\telement.style.border = '1px solid #fff';\n\t\t\telement.style.borderRadius = '4px';\n\t\t\telement.style.background = 'rgba(0,0,0,0.1)';\n\t\t\telement.style.color = '#fff';\n\t\t\telement.style.font = 'normal 13px sans-serif';\n\t\t\telement.style.textAlign = 'center';\n\t\t\telement.style.opacity = '0.5';\n\t\t\telement.style.outline = 'none';\n\t\t\telement.style.zIndex = '999';\n\n\t\t}\n\n\t\tif ( 'xr' in navigator ) {\n\n\t\t\tbutton.id = 'VRButton';\n\t\t\tbutton.style.display = 'none';\n\n\t\t\tstylizeElement( button );\n\n\t\t\tnavigator.xr.isSessionSupported( 'immersive-vr' ).then( function ( supported ) {\n\n\t\t\t\tsupported ? showEnterVR() : showWebXRNotFound();\n\n\t\t\t\tif ( supported && VRButton.xrSessionIsGranted ) {\n\n\t\t\t\t\tbutton.click();\n\n\t\t\t\t}\n\n\t\t\t} ).catch( showVRNotAllowed );\n\n\t\t\treturn button;\n\n\t\t} else {\n\n\t\t\tconst message = document.createElement( 'a' );\n\n\t\t\tif ( window.isSecureContext === false ) {\n\n\t\t\t\tmessage.href = document.location.href.replace( /^http:/, 'https:' );\n\t\t\t\tmessage.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message\n\n\t\t\t} else {\n\n\t\t\t\tmessage.href = 'https://immersiveweb.dev/';\n\t\t\t\tmessage.innerHTML = 'WEBXR NOT AVAILABLE';\n\n\t\t\t}\n\n\t\t\tmessage.style.left = 'calc(50% - 90px)';\n\t\t\tmessage.style.width = '180px';\n\t\t\tmessage.style.textDecoration = 'none';\n\n\t\t\tstylizeElement( message );\n\n\t\t\treturn message;\n\n\t\t}\n\n\t}\n\n\tstatic xrSessionIsGranted = false;\n\n\tstatic registerSessionGrantedListener() {\n\n\t\tif ( 'xr' in navigator ) {\n\n\t\t\tnavigator.xr.addEventListener( 'sessiongranted', () => {\n\n\t\t\t\tVRButton.xrSessionIsGranted = true;\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nVRButton.registerSessionGrantedListener();\n\nexport { VRButton };\n","import {\n\tAnimationClip,\n\tBone,\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFrontSide,\n\tGroup,\n\tImageBitmapLoader,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tInterpolant,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLine,\n\tLineBasicMaterial,\n\tLineLoop,\n\tLineSegments,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tLoader,\n\tLoaderUtils,\n\tMaterial,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tNumberKeyframeTrack,\n\tObject3D,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tPoints,\n\tPointsMaterial,\n\tPropertyBinding,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSkeleton,\n\tSkinnedMesh,\n\tSphere,\n\tSpotLight,\n\tTangentSpaceNormalMap,\n\tTexture,\n\tTextureLoader,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tsRGBEncoding\n} from 'three';\n\nclass GLTFLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\tresourcePath = this.path;\n\n\t\t} else {\n\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\tthis.manager.itemStart( url );\n\n\t\tconst _onError = function ( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, _onError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\t_onError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, _onError );\n\n\t}\n\n\tsetDRACOLoader( dracoLoader ) {\n\n\t\tthis.dracoLoader = dracoLoader;\n\t\treturn this;\n\n\t}\n\n\tsetDDSLoader() {\n\n\t\tthrow new Error(\n\n\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t);\n\n\t}\n\n\tsetKTX2Loader( ktx2Loader ) {\n\n\t\tthis.ktx2Loader = ktx2Loader;\n\t\treturn this;\n\n\t}\n\n\tsetMeshoptDecoder( meshoptDecoder ) {\n\n\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\treturn this;\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tparse( data, path, onLoad, onError ) {\n\n\t\tlet content;\n\t\tconst extensions = {};\n\t\tconst plugins = {};\n\n\t\tif ( typeof data === 'string' ) {\n\n\t\t\tcontent = data;\n\n\t\t} else {\n\n\t\t\tconst magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );\n\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\n\n\t\t\t} else {\n\n\t\t\t\tcontent = LoaderUtils.decodeText( new Uint8Array( data ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst json = JSON.parse( content );\n\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst parser = new GLTFParser( json, {\n\n\t\t\tpath: path || this.resourcePath || '',\n\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\trequestHeader: this.requestHeader,\n\t\t\tmanager: this.manager,\n\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t} );\n\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\n\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t// Remove this workaround if we move all the existing\n\t\t\t// extension handlers to plugin system\n\t\t\textensions[ plugin.name ] = true;\n\n\t\t}\n\n\t\tif ( json.extensionsUsed ) {\n\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tparser.setExtensions( extensions );\n\t\tparser.setPlugins( plugins );\n\t\tparser.parse( onLoad, onError );\n\n\t}\n\n\tparseAsync( data, path ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( data, path, resolve, reject );\n\n\t\t} );\n\n\t}\n\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n\n\tlet objects = {};\n\n\treturn\t{\n\n\t\tget: function ( key ) {\n\n\t\t\treturn objects[ key ];\n\n\t\t},\n\n\t\tadd: function ( key, object ) {\n\n\t\t\tobjects[ key ] = object;\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete objects[ key ];\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\tobjects = {};\n\n\t\t}\n\n\t};\n\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\n\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\tKHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\n};\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\t_markDefs() {\n\n\t\tconst parser = this.parser;\n\t\tconst nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_loadLight( lightIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst cacheKey = 'light:' + lightIndex;\n\t\tlet dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tconst json = parser.json;\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tconst lightDefs = extensions.lights || [];\n\t\tconst lightDef = lightDefs[ lightIndex ];\n\t\tlet lightNode;\n\n\t\tconst color = new Color( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t}\n\n\tcreateNodeAttachment( nodeIndex ) {\n\n\t\tconst self = this;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tconst lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn MeshBasicMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\tmaterialParams.clearcoatNormalScale = new Vector2( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.sheenColor = new Color( 0, 0, 0 );\n\t\tmaterialParams.sheenRoughness = 0;\n\t\tmaterialParams.sheen = 1;\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.sheenColorFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenColor.fromArray( extension.sheenColorFactor );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenRoughness = extension.sheenRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.sheenColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture ) );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n\t\tif ( extension.thicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || 0;\n\n\t\tconst colorArray = extension.attenuationColor || [ 1, 1, 1 ];\n\t\tmaterialParams.attenuationColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n\t\tif ( extension.specularTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );\n\n\t\t}\n\n\t\tconst colorArray = extension.specularColorFactor || [ 1, 1, 1 ];\n\t\tmaterialParams.specularColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );\n\n\t\tif ( extension.specularColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture ).then( function ( texture ) {\n\n\t\t\t\ttexture.encoding = sRGBEncoding;\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ this.name ];\n\t\tconst loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tloadBufferView( index ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {\n\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tconst count = extensionDef.count;\n\t\t\t\tconst stride = extensionDef.byteStride;\n\n\t\t\t\tconst result = new ArrayBuffer( count * stride );\n\t\t\t\tconst source = new Uint8Array( res[ 0 ], byteOffset, byteLength );\n\n\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\treturn result;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nclass GLTFBinaryExtension {\n\n\tconstructor( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\n\t\tthis.header = {\n\t\t\tmagic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tlet chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = LoaderUtils.decodeText( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n\n\tconstructor( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tdecodePrimitive( primitive, parser ) {\n\n\t\tconst json = this.json;\n\t\tconst dracoLoader = this.dracoLoader;\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tconst threeAttributeMap = {};\n\t\tconst attributeNormalizedMap = {};\n\t\tconst attributeTypeMap = {};\n\n\t\tfor ( const attributeName in gltfAttributeMap ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( const attributeName in primitive.attributes ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\textendTexture( texture, transform ) {\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\n\n\t\t}\n\n\t\tif ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\n\t\t\treturn texture;\n\n\t\t}\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness\n */\n\n/**\n * A sub class of StandardMaterial with some of the functionality\n * changed via the `onBeforeCompile` callback\n * @pailhead\n */\nclass GLTFMeshStandardSGMaterial extends MeshStandardMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper();\n\n\t\tthis.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t//various chunks that need replacing\n\t\tconst specularMapParsFragmentChunk = [\n\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t'\tuniform sampler2D specularMap;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tconst glossinessMapParsFragmentChunk = [\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t'\tuniform sampler2D glossinessMap;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tconst specularMapFragmentChunk = [\n\t\t\t'vec3 specularFactor = specular;',\n\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tconst glossinessMapFragmentChunk = [\n\t\t\t'float glossinessFactor = glossiness;',\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tconst lightPhysicalFragmentChunk = [\n\t\t\t'PhysicalMaterial material;',\n\t\t\t'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',\n\t\t\t'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\n\t\t\t'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\n\t\t\t'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',\n\t\t\t'material.roughness += geometryRoughness;',\n\t\t\t'material.roughness = min( material.roughness, 1.0 );',\n\t\t\t'material.specularColor = specularFactor;',\n\t\t].join( '\\n' );\n\n\t\tconst uniforms = {\n\t\t\tspecular: { value: new Color().setHex( 0xffffff ) },\n\t\t\tglossiness: { value: 1 },\n\t\t\tspecularMap: { value: null },\n\t\t\tglossinessMap: { value: null }\n\t\t};\n\n\t\tthis._extraUniforms = uniforms;\n\n\t\tthis.onBeforeCompile = function ( shader ) {\n\n\t\t\tfor ( const uniformName in uniforms ) {\n\n\t\t\t\tshader.uniforms[ uniformName ] = uniforms[ uniformName ];\n\n\t\t\t}\n\n\t\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\n\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\n\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\n\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\n\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\n\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\n\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\n\n\t\t};\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tspecular: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.specular.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.specular.value = v;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tspecularMap: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.specularMap.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.specularMap.value = v;\n\n\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\tthis.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_SPECULARMAP;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tglossiness: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.glossiness.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.glossiness.value = v;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tglossinessMap: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.glossinessMap.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.glossinessMap.value = v;\n\n\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\tthis.defines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t\tthis.defines.USE_UV = '';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_GLOSSINESSMAP;\n\t\t\t\t\t\tdelete this.defines.USE_UV;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tdelete this.metalness;\n\t\tdelete this.roughness;\n\t\tdelete this.metalnessMap;\n\t\tdelete this.roughnessMap;\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.specularMap = source.specularMap;\n\t\tthis.specular.copy( source.specular );\n\t\tthis.glossinessMap = source.glossinessMap;\n\t\tthis.glossiness = source.glossiness;\n\t\tdelete this.metalness;\n\t\tdelete this.roughness;\n\t\tdelete this.metalnessMap;\n\t\tdelete this.roughnessMap;\n\t\treturn this;\n\n\t}\n\n}\n\n\nclass GLTFMaterialsPbrSpecularGlossinessExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\n\t\tthis.specularGlossinessParams = [\n\t\t\t'color',\n\t\t\t'map',\n\t\t\t'lightMap',\n\t\t\t'lightMapIntensity',\n\t\t\t'aoMap',\n\t\t\t'aoMapIntensity',\n\t\t\t'emissive',\n\t\t\t'emissiveIntensity',\n\t\t\t'emissiveMap',\n\t\t\t'bumpMap',\n\t\t\t'bumpScale',\n\t\t\t'normalMap',\n\t\t\t'normalMapType',\n\t\t\t'displacementMap',\n\t\t\t'displacementScale',\n\t\t\t'displacementBias',\n\t\t\t'specularMap',\n\t\t\t'specular',\n\t\t\t'glossinessMap',\n\t\t\t'glossiness',\n\t\t\t'alphaMap',\n\t\t\t'envMap',\n\t\t\t'envMapIntensity',\n\t\t\t'refractionRatio',\n\t\t];\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn GLTFMeshStandardSGMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pbrSpecularGlossiness = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst pending = [];\n\n\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\n\n\t\t\tconst array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\tmaterialParams.color.fromArray( array );\n\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t}\n\n\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.emissive = new Color( 0.0, 0.0, 0.0 );\n\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\tmaterialParams.specular = new Color( 1.0, 1.0, 1.0 );\n\n\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\n\n\t\t\tmaterialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\n\n\t\t}\n\n\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\n\n\t\t\tconst specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n\t\t\tpending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\tcreateMaterial( materialParams ) {\n\n\t\tconst material = new GLTFMeshStandardSGMaterial( materialParams );\n\t\tmaterial.fog = true;\n\n\t\tmaterial.color = materialParams.color;\n\n\t\tmaterial.map = materialParams.map === undefined ? null : materialParams.map;\n\n\t\tmaterial.lightMap = null;\n\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\tmaterial.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\tmaterial.emissive = materialParams.emissive;\n\t\tmaterial.emissiveIntensity = 1.0;\n\t\tmaterial.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n\n\t\tmaterial.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n\t\tmaterial.bumpScale = 1;\n\n\t\tmaterial.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n\t\tmaterial.normalMapType = TangentSpaceNormalMap;\n\n\t\tif ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;\n\n\t\tmaterial.displacementMap = null;\n\t\tmaterial.displacementScale = 1;\n\t\tmaterial.displacementBias = 0;\n\n\t\tmaterial.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n\t\tmaterial.specular = materialParams.specular;\n\n\t\tmaterial.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n\t\tmaterial.glossiness = materialParams.glossiness;\n\n\t\tmaterial.alphaMap = null;\n\n\t\tmaterial.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n\t\tmaterial.envMapIntensity = 1.0;\n\n\t\tmaterial.refractionRatio = 0.98;\n\n\t\treturn material;\n\n\t}\n\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\nGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\nGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\n\n\tconst result = this.resultBuffer;\n\tconst values = this.sampleValues;\n\tconst stride = this.valueSize;\n\n\tconst stride2 = stride * 2;\n\tconst stride3 = stride * 3;\n\n\tconst td = t1 - t0;\n\n\tconst p = ( t - t0 ) / td;\n\tconst pp = p * p;\n\tconst ppp = pp * p;\n\n\tconst offset1 = i1 * stride3;\n\tconst offset0 = offset1 - stride3;\n\n\tconst s2 = - 2 * ppp + 3 * pp;\n\tconst s3 = ppp - pp;\n\tconst s0 = 1 - s2;\n\tconst s1 = s3 - pp + p;\n\n\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\tfor ( let i = 0; i !== stride; i ++ ) {\n\n\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t}\n\n\treturn result;\n\n};\n\nconst _q = new Quaternion();\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = super.interpolate_( i1, t0, t, t1 );\n\n\t\t_q.fromArray( result ).normalize().toArray( result );\n\n\t\treturn result;\n\n\t}\n\n}\n\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n\tFLOAT: 5126,\n\t//FLOAT_MAT2: 35674,\n\tFLOAT_MAT3: 35675,\n\tFLOAT_MAT4: 35676,\n\tFLOAT_VEC2: 35664,\n\tFLOAT_VEC3: 35665,\n\tFLOAT_VEC4: 35666,\n\tLINEAR: 9729,\n\tREPEAT: 10497,\n\tSAMPLER_2D: 35678,\n\tPOINTS: 0,\n\tLINES: 1,\n\tLINE_LOOP: 2,\n\tLINE_STRIP: 3,\n\tTRIANGLES: 4,\n\tTRIANGLE_STRIP: 5,\n\tTRIANGLE_FAN: 6,\n\tUNSIGNED_BYTE: 5121,\n\tUNSIGNED_SHORT: 5123\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n\t5120: Int8Array,\n\t5121: Uint8Array,\n\t5122: Int16Array,\n\t5123: Uint16Array,\n\t5125: Uint32Array,\n\t5126: Float32Array\n};\n\nconst WEBGL_FILTERS = {\n\t9728: NearestFilter,\n\t9729: LinearFilter,\n\t9984: NearestMipmapNearestFilter,\n\t9985: LinearMipmapNearestFilter,\n\t9986: NearestMipmapLinearFilter,\n\t9987: LinearMipmapLinearFilter\n};\n\nconst WEBGL_WRAPPINGS = {\n\t33071: ClampToEdgeWrapping,\n\t33648: MirroredRepeatWrapping,\n\t10497: RepeatWrapping\n};\n\nconst WEBGL_TYPE_SIZES = {\n\t'SCALAR': 1,\n\t'VEC2': 2,\n\t'VEC3': 3,\n\t'VEC4': 4,\n\t'MAT2': 4,\n\t'MAT3': 9,\n\t'MAT4': 16\n};\n\nconst ATTRIBUTES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n\tTANGENT: 'tangent',\n\tTEXCOORD_0: 'uv',\n\tTEXCOORD_1: 'uv2',\n\tCOLOR_0: 'color',\n\tWEIGHTS_0: 'skinWeight',\n\tJOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\ttranslation: 'position',\n\trotation: 'quaternion',\n\tweights: 'morphTargetInfluences'\n};\n\nconst INTERPOLATION = {\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\tLINEAR: InterpolateLinear,\n\tSTEP: InterpolateDiscrete\n};\n\nconst ALPHA_MODES = {\n\tOPAQUE: 'OPAQUE',\n\tMASK: 'MASK',\n\tBLEND: 'BLEND'\n};\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial( cache ) {\n\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\tcache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: FrontSide\n\t\t} );\n\n\t}\n\n\treturn cache[ 'DefaultMaterial' ];\n\n}\n\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t// Add unknown glTF extensions to an object's userData.\n\n\tfor ( const name in objectDef.extensions ) {\n\n\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData( object, gltfDef ) {\n\n\tif ( gltfDef.extras !== undefined ) {\n\n\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets( geometry, targets, parser ) {\n\n\tlet hasMorphPosition = false;\n\tlet hasMorphNormal = false;\n\tlet hasMorphColor = false;\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\t\tif ( target.COLOR_0 !== undefined ) hasMorphColor = true;\n\n\t\tif ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;\n\n\t}\n\n\tif ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );\n\n\tconst pendingPositionAccessors = [];\n\tconst pendingNormalAccessors = [];\n\tconst pendingColorAccessors = [];\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( hasMorphPosition ) {\n\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t: geometry.attributes.position;\n\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphNormal ) {\n\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t: geometry.attributes.normal;\n\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphColor ) {\n\n\t\t\tconst pendingAccessor = target.COLOR_0 !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.COLOR_0 )\n\t\t\t\t: geometry.attributes.color;\n\n\t\t\tpendingColorAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t}\n\n\treturn Promise.all( [\n\t\tPromise.all( pendingPositionAccessors ),\n\t\tPromise.all( pendingNormalAccessors ),\n\t\tPromise.all( pendingColorAccessors )\n\t] ).then( function ( accessors ) {\n\n\t\tconst morphPositions = accessors[ 0 ];\n\t\tconst morphNormals = accessors[ 1 ];\n\t\tconst morphColors = accessors[ 2 ];\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\tif ( hasMorphColor ) geometry.morphAttributes.color = morphColors;\n\t\tgeometry.morphTargetsRelative = true;\n\n\t\treturn geometry;\n\n\t} );\n\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets( mesh, meshDef ) {\n\n\tmesh.updateMorphTargets();\n\n\tif ( meshDef.weights !== undefined ) {\n\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t}\n\n\t}\n\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\tconst targetNames = meshDef.extras.targetNames;\n\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction createPrimitiveKey( primitiveDef ) {\n\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\tlet geometryKey;\n\n\tif ( dracoExtension ) {\n\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t} else {\n\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t}\n\n\treturn geometryKey;\n\n}\n\nfunction createAttributesKey( attributes ) {\n\n\tlet attributesKey = '';\n\n\tconst keys = Object.keys( attributes ).sort();\n\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t}\n\n\treturn attributesKey;\n\n}\n\nfunction getNormalizedComponentScale( constructor ) {\n\n\t// Reference:\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n\tswitch ( constructor ) {\n\n\t\tcase Int8Array:\n\t\t\treturn 1 / 127;\n\n\t\tcase Uint8Array:\n\t\t\treturn 1 / 255;\n\n\t\tcase Int16Array:\n\t\t\treturn 1 / 32767;\n\n\t\tcase Uint16Array:\n\t\t\treturn 1 / 65535;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\n\n\t}\n\n}\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n\n\tconstructor( json = {}, options = {} ) {\n\n\t\tthis.json = json;\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options;\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\tthis.sourceCache = {};\n\t\tthis.textureCache = {};\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\t\tif ( typeof createImageBitmap !== 'undefined' && /Firefox|^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === false ) {\n\n\t\t\tthis.textureLoader = new ImageBitmapLoader( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new TextureLoader( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tsetExtensions( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tparse( onLoad, onError ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tconst result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\tPromise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t}\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\t_markDefs() {\n\n\t\tconst nodeDefs = this.json.nodes || [];\n\t\tconst skinDefs = this.json.skins || [];\n\t\tconst meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\t_addNodeRef( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t}\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\t_getNodeRef( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tconst ref = object.clone();\n\n\t\t// Propagates mappings to the cloned object, prevents mappings on the\n\t\t// original object from being lost.\n\t\tconst updateMappings = ( original, clone ) => {\n\n\t\t\tconst mappings = this.associations.get( original );\n\t\t\tif ( mappings != null ) {\n\n\t\t\t\tthis.associations.set( clone, mappings );\n\n\t\t\t}\n\n\t\t\tfor ( const [ i, child ] of original.children.entries() ) {\n\n\t\t\t\tupdateMappings( child, clone.children[ i ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tupdateMappings( object, ref );\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t}\n\n\t_invokeOne( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t}\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tgetDependency( type, index ) {\n\n\t\tconst cacheKey = type + ':' + index;\n\t\tlet dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this.loadNode( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this.loadAnimation( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t}\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tgetDependencies( type ) {\n\n\t\tlet dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tconst parser = this;\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBuffer( bufferIndex ) {\n\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\n\t\tconst loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tconst options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBufferView( bufferViewIndex ) {\n\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tloadAccessor( accessorIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t// compression extension).\n\t\t\treturn Promise.resolve( null );\n\n\t\t}\n\n\t\tconst pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tconst bufferView = bufferViews[ 0 ];\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tconst itemBytes = elementBytes * itemSize;\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tconst normalized = accessorDef.normalized === true;\n\t\t\tlet array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture>}\n\t */\n\tloadTexture( textureIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceIndex = textureDef.source;\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tlet loader = this.textureLoader;\n\n\t\tif ( sourceDef.uri ) {\n\n\t\t\tconst handler = options.manager.getHandler( sourceDef.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, sourceIndex, loader );\n\n\t}\n\n\tloadTextureImage( textureIndex, sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;\n\n\t\tif ( this.textureCache[ cacheKey ] ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\n\t\t\treturn this.textureCache[ cacheKey ];\n\n\t\t}\n\n\t\tconst promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {\n\n\t\t\ttexture.flipY = false;\n\n\t\t\tif ( textureDef.name ) texture.name = textureDef.name;\n\n\t\t\tconst samplers = json.samplers || {};\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\n\n\t\t\tparser.associations.set( texture, { textures: textureIndex } );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function () {\n\n\t\t\treturn null;\n\n\t\t} );\n\n\t\tthis.textureCache[ cacheKey ] = promise;\n\n\t\treturn promise;\n\n\t}\n\n\tloadImageSource( sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( this.sourceCache[ sourceIndex ] !== undefined ) {\n\n\t\t\treturn this.sourceCache[ sourceIndex ].then( function ( texture ) {\n\n\t\t\t\treturn texture.clone();\n\n\t\t\t} ).catch( function ( error ) {\n\n\t\t\t\tthrow error;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst URL = self.URL || self.webkitURL;\n\n\t\tlet sourceURI = sourceDef.uri || '';\n\t\tlet isObjectURL = false;\n\n\t\tif ( sourceDef.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( sourceDef.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tlet onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tconst texture = new Texture( imageBitmap );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tresolve( texture );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function ( error ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\n\t\t\tthrow error;\n\n\t\t} );\n\n\t\tthis.sourceCache[ sourceIndex ] = promise;\n\t\treturn promise;\n\n\t}\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise<Texture>}\n\t */\n\tassignTexture( materialParams, mapName, mapDef ) {\n\n\t\tconst parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tassignFinalMaterial( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet material = mesh.material;\n\n\t\tconst useDerivativeTangents = geometry.attributes.tangent === undefined;\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new PointsMaterial();\n\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new LineBasicMaterial();\n\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useDerivativeTangents || useVertexColors || useFlatShading ) {\n\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\n\t\t\tif ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\n\t\t\t\tif ( useDerivativeTangents ) {\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\t// workarounds for mesh and geometry\n\n\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\n\n\t\t\tgeometry.setAttribute( 'uv2', geometry.attributes.uv );\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t}\n\n\tgetMaterialType( /* materialIndex */ ) {\n\n\t\treturn MeshStandardMaterial;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tloadMaterial( materialIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst materialDef = json.materials[ materialIndex ];\n\n\t\tlet materialType;\n\t\tconst materialParams = {};\n\t\tconst materialExtensions = materialDef.extensions || {};\n\n\t\tconst pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\n\n\t\t\tconst sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\n\t\t\tmaterialType = sgExtension.getMaterialType();\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = DoubleSide;\n\n\t\t}\n\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = materialDef.normalTexture.scale;\n\n\t\t\t\tmaterialParams.normalScale.set( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tmaterialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tlet material;\n\n\t\t\tif ( materialType === GLTFMeshStandardSGMaterial ) {\n\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new materialType( materialParams );\n\n\t\t\t}\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\t\t\tif ( material.map ) material.map.encoding = sRGBEncoding;\n\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = sRGBEncoding;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { materials: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t}\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tcreateUniqueName( originalName ) {\n\n\t\tconst sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );\n\n\t\tlet name = sanitizedName;\n\n\t\tfor ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {\n\n\t\t\tname = sanitizedName + '_' + i;\n\n\t\t}\n\n\t\tthis.nodeNamesUsed[ name ] = true;\n\n\t\treturn name;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tloadGeometries( primitives ) {\n\n\t\tconst parser = this;\n\t\tconst extensions = this.extensions;\n\t\tconst cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = primitives[ i ];\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tconst cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tlet geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tloadMesh( meshIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\tconst meshDef = json.meshes[ meshIndex ];\n\t\tconst primitives = meshDef.primitives;\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\n\t\t\tconst geometries = results[ results.length - 1 ];\n\n\t\t\tconst meshes = [];\n\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\n\t\t\t\t\t\t: new Mesh( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {\n\n\t\t\t\t\t\t// we normalize floating point skin weight array to fix malformed assets (see #15319)\n\t\t\t\t\t\t// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new LineSegments( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new Line( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new LineLoop( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new Points( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tparser.associations.set( meshes[ i ], {\n\t\t\t\t\tmeshes: meshIndex,\n\t\t\t\t\tprimitives: i\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\n\t\t\tparser.associations.set( group, { meshes: meshIndex } );\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tloadCamera( cameraIndex ) {\n\n\t\tlet camera;\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\n\t\tconst params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Object>}\n\t */\n\tloadSkin( skinIndex ) {\n\n\t\tconst skinDef = this.json.skins[ skinIndex ];\n\n\t\tconst skinEntry = { joints: skinDef.joints };\n\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\n\n\t\t\treturn Promise.resolve( skinEntry );\n\n\t\t}\n\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\n\n\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\treturn skinEntry;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst json = this.json;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tnode.updateMatrix();\n\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\tlet TypedKeyframeTrack;\n\n\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tconst targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\n\n\t\t\t\tconst targetNames = [];\n\n\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetNames.push( targetName );\n\n\t\t\t\t}\n\n\t\t\t\tlet outputArray = outputAccessor.array;\n\n\t\t\t\tif ( outputAccessor.normalized ) {\n\n\t\t\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\n\t\t\t\t\tconst scaled = new Float32Array( outputArray.length );\n\n\t\t\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputArray = scaled;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\t\t\tinputAccessor.array,\n\t\t\t\t\t\toutputArray,\n\t\t\t\t\t\tinterpolation\n\t\t\t\t\t);\n\n\t\t\t\t\t// Override interpolation with custom factory method.\n\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\tconst interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n\n\t\t\t\t\t\t\treturn new interpolantType( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( track );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new AnimationClip( name, undefined, tracks );\n\n\t\t} );\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( nodeDef.mesh === undefined ) return null;\n\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tloadNode( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst parser = this;\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\treturn ( function () {\n\n\t\t\tconst pending = [];\n\n\t\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\n\n\t\t\t} );\n\n\t\t\tif ( meshPromise ) {\n\n\t\t\t\tpending.push( meshPromise );\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t\t} ).forEach( function ( promise ) {\n\n\t\t\t\tpending.push( promise );\n\n\t\t\t} );\n\n\t\t\treturn Promise.all( pending );\n\n\t\t}() ).then( function ( objects ) {\n\n\t\t\tlet node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new Bone();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new Group();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new Object3D();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tconst matrix = new Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! parser.associations.has( node ) ) {\n\n\t\t\t\tparser.associations.set( node, {} );\n\n\t\t\t}\n\n\t\t\tparser.associations.get( node ).nodes = nodeIndex;\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tloadScene( sceneIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\n\t\tconst parser = this;\n\n\t\t// Loader returns Group, not Scene.\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\tconst scene = new Group();\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\tconst nodeIds = sceneDef.nodes || [];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\tpending.push( buildNodeHierarchy( nodeIds[ i ], scene, json, parser ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\t// Removes dangling associations, associations that reference a node that\n\t\t\t// didn't make it into the scene.\n\t\t\tconst reduceAssociations = ( node ) => {\n\n\t\t\t\tconst reducedAssociations = new Map();\n\n\t\t\t\tfor ( const [ key, value ] of parser.associations ) {\n\n\t\t\t\t\tif ( key instanceof Material || key instanceof Texture ) {\n\n\t\t\t\t\t\treducedAssociations.set( key, value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnode.traverse( ( node ) => {\n\n\t\t\t\t\tconst mappings = parser.associations.get( node );\n\n\t\t\t\t\tif ( mappings != null ) {\n\n\t\t\t\t\t\treducedAssociations.set( node, mappings );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn reducedAssociations;\n\n\t\t\t};\n\n\t\t\tparser.associations = reduceAssociations( scene );\n\n\t\t\treturn scene;\n\n\t\t} );\n\n\t}\n\n}\n\nfunction buildNodeHierarchy( nodeId, parentObject, json, parser ) {\n\n\tconst nodeDef = json.nodes[ nodeId ];\n\n\treturn parser.getDependency( 'node', nodeId ).then( function ( node ) {\n\n\t\tif ( nodeDef.skin === undefined ) return node;\n\n\t\t// build skeleton here as well\n\n\t\tlet skinEntry;\n\n\t\treturn parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {\n\n\t\t\tskinEntry = skin;\n\n\t\t\tconst pendingJoints = [];\n\n\t\t\tfor ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {\n\n\t\t\t\tpendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pendingJoints );\n\n\t\t} ).then( function ( jointNodes ) {\n\n\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\tif ( ! mesh.isMesh ) return;\n\n\t\t\t\tconst bones = [];\n\t\t\t\tconst boneInverses = [];\n\n\t\t\t\tfor ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst jointNode = jointNodes[ j ];\n\n\t\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\t\tconst mat = new Matrix4();\n\n\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\n\n\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmesh.bind( new Skeleton( bones, boneInverses ), mesh.matrixWorld );\n\n\t\t\t} );\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t} ).then( function ( node ) {\n\n\t\t// build node hierachy\n\n\t\tparentObject.add( node );\n\n\t\tconst pending = [];\n\n\t\tif ( nodeDef.children ) {\n\n\t\t\tconst children = nodeDef.children;\n\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tpending.push( buildNodeHierarchy( child, node, json, parser ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t} );\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst box = new Box3();\n\n\tif ( attributes.POSITION !== undefined ) {\n\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\tconst min = accessor.min;\n\t\tconst max = accessor.max;\n\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\tbox.set(\n\t\t\t\tnew Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\tnew Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\n\t\t\t);\n\n\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\tbox.min.multiplyScalar( boxScale );\n\t\t\t\tbox.max.multiplyScalar( boxScale );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\treturn;\n\n\t}\n\n\tconst targets = primitiveDef.targets;\n\n\tif ( targets !== undefined ) {\n\n\t\tconst maxDisplacement = new Vector3();\n\t\tconst vector = new Vector3();\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tconst target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\tconst min = accessor.min;\n\t\t\t\tconst max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\n\t\t\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\tbox.expandByVector( maxDisplacement );\n\n\t}\n\n\tgeometry.boundingBox = box;\n\n\tconst sphere = new Sphere();\n\n\tbox.getCenter( sphere.center );\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\tgeometry.boundingSphere = sphere;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst pending = [];\n\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t.then( function ( accessor ) {\n\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t} );\n\n\t}\n\n\tfor ( const gltfAttributeName in attributes ) {\n\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t}\n\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\tgeometry.setIndex( accessor );\n\n\t\t} );\n\n\t\tpending.push( accessor );\n\n\t}\n\n\tassignExtrasToUserData( geometry, primitiveDef );\n\n\tcomputeBounds( geometry, primitiveDef, parser );\n\n\treturn Promise.all( pending ).then( function () {\n\n\t\treturn primitiveDef.targets !== undefined\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t: geometry;\n\n\t} );\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {Number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tlet index = geometry.getIndex();\n\n\t// generate index if not present\n\n\tif ( index === null ) {\n\n\t\tconst indices = [];\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\tindices.push( i );\n\n\t\t\t}\n\n\t\t\tgeometry.setIndex( indices );\n\t\t\tindex = geometry.getIndex();\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t}\n\n\t//\n\n\tconst numberOfTriangles = index.count - 2;\n\tconst newIndices = [];\n\n\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t// gl.TRIANGLE_FAN\n\n\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t}\n\n\t} else {\n\n\t\t// gl.TRIANGLE_STRIP\n\n\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t} else {\n\n\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t}\n\n\t// build final geometry\n\n\tconst newGeometry = geometry.clone();\n\tnewGeometry.setIndex( newIndices );\n\n\treturn newGeometry;\n\n}\n\nexport { GLTFLoader };\n","/**\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\n */\n\nconst Constants = {\n  Handedness: Object.freeze({\n    NONE: 'none',\n    LEFT: 'left',\n    RIGHT: 'right'\n  }),\n\n  ComponentState: Object.freeze({\n    DEFAULT: 'default',\n    TOUCHED: 'touched',\n    PRESSED: 'pressed'\n  }),\n\n  ComponentProperty: Object.freeze({\n    BUTTON: 'button',\n    X_AXIS: 'xAxis',\n    Y_AXIS: 'yAxis',\n    STATE: 'state'\n  }),\n\n  ComponentType: Object.freeze({\n    TRIGGER: 'trigger',\n    SQUEEZE: 'squeeze',\n    TOUCHPAD: 'touchpad',\n    THUMBSTICK: 'thumbstick',\n    BUTTON: 'button'\n  }),\n\n  ButtonTouchThreshold: 0.05,\n\n  AxisTouchThreshold: 0.1,\n\n  VisualResponseProperty: Object.freeze({\n    TRANSFORM: 'transform',\n    VISIBILITY: 'visibility'\n  })\n};\n\n/**\n * @description Static helper function to fetch a JSON file and turn it into a JS object\n * @param {string} path - Path to JSON file to be fetched\n */\nasync function fetchJsonFile(path) {\n  const response = await fetch(path);\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  } else {\n    return response.json();\n  }\n}\n\nasync function fetchProfilesList(basePath) {\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  const profileListFileName = 'profilesList.json';\n  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);\n  return profilesList;\n}\n\nasync function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {\n  if (!xrInputSource) {\n    throw new Error('No xrInputSource supplied');\n  }\n\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  // Get the list of profiles\n  const supportedProfilesList = await fetchProfilesList(basePath);\n\n  // Find the relative path to the first requested profile that is recognized\n  let match;\n  xrInputSource.profiles.some((profileId) => {\n    const supportedProfile = supportedProfilesList[profileId];\n    if (supportedProfile) {\n      match = {\n        profileId,\n        profilePath: `${basePath}/${supportedProfile.path}`,\n        deprecated: !!supportedProfile.deprecated\n      };\n    }\n    return !!match;\n  });\n\n  if (!match) {\n    if (!defaultProfile) {\n      throw new Error('No matching profile name found');\n    }\n\n    const supportedProfile = supportedProfilesList[defaultProfile];\n    if (!supportedProfile) {\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`);\n    }\n\n    match = {\n      profileId: defaultProfile,\n      profilePath: `${basePath}/${supportedProfile.path}`,\n      deprecated: !!supportedProfile.deprecated\n    };\n  }\n\n  const profile = await fetchJsonFile(match.profilePath);\n\n  let assetPath;\n  if (getAssetPath) {\n    let layout;\n    if (xrInputSource.handedness === 'any') {\n      layout = profile.layouts[Object.keys(profile.layouts)[0]];\n    } else {\n      layout = profile.layouts[xrInputSource.handedness];\n    }\n    if (!layout) {\n      throw new Error(\n        `No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`\n      );\n    }\n\n    if (layout.assetPath) {\n      assetPath = match.profilePath.replace('profile.json', layout.assetPath);\n    }\n  }\n\n  return { profile, assetPath };\n}\n\n/** @constant {Object} */\nconst defaultComponentValues = {\n  xAxis: 0,\n  yAxis: 0,\n  button: 0,\n  state: Constants.ComponentState.DEFAULT\n};\n\n/**\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\n * range of motion and touchpads do not report touch locations off their physical bounds.\n * @param {number} x The original x coordinate in the range -1 to 1\n * @param {number} y The original y coordinate in the range -1 to 1\n */\nfunction normalizeAxes(x = 0, y = 0) {\n  let xAxis = x;\n  let yAxis = y;\n\n  // Determine if the point is outside the bounds of the circle\n  // and, if so, place it on the edge of the circle\n  const hypotenuse = Math.sqrt((x * x) + (y * y));\n  if (hypotenuse > 1) {\n    const theta = Math.atan2(y, x);\n    xAxis = Math.cos(theta);\n    yAxis = Math.sin(theta);\n  }\n\n  // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\n  const result = {\n    normalizedXAxis: (xAxis * 0.5) + 0.5,\n    normalizedYAxis: (yAxis * 0.5) + 0.5\n  };\n  return result;\n}\n\n/**\n * Contains the description of how the 3D model should visually respond to a specific user input.\n * This is accomplished by initializing the object with the name of a node in the 3D model and\n * property that need to be modified in response to user input, the name of the nodes representing\n * the allowable range of motion, and the name of the input which triggers the change. In response\n * to the named input changing, this object computes the appropriate weighting to use for\n * interpolating between the range of motion nodes.\n */\nclass VisualResponse {\n  constructor(visualResponseDescription) {\n    this.componentProperty = visualResponseDescription.componentProperty;\n    this.states = visualResponseDescription.states;\n    this.valueNodeName = visualResponseDescription.valueNodeName;\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;\n\n    if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {\n      this.minNodeName = visualResponseDescription.minNodeName;\n      this.maxNodeName = visualResponseDescription.maxNodeName;\n    }\n\n    // Initializes the response's current value based on default data\n    this.value = 0;\n    this.updateFromComponent(defaultComponentValues);\n  }\n\n  /**\n   * Computes the visual response's interpolation weight based on component state\n   * @param {Object} componentValues - The component from which to update\n   * @param {number} xAxis - The reported X axis value of the component\n   * @param {number} yAxis - The reported Y axis value of the component\n   * @param {number} button - The reported value of the component's button\n   * @param {string} state - The component's active state\n   */\n  updateFromComponent({\n    xAxis, yAxis, button, state\n  }) {\n    const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis);\n    switch (this.componentProperty) {\n      case Constants.ComponentProperty.X_AXIS:\n        this.value = (this.states.includes(state)) ? normalizedXAxis : 0.5;\n        break;\n      case Constants.ComponentProperty.Y_AXIS:\n        this.value = (this.states.includes(state)) ? normalizedYAxis : 0.5;\n        break;\n      case Constants.ComponentProperty.BUTTON:\n        this.value = (this.states.includes(state)) ? button : 0;\n        break;\n      case Constants.ComponentProperty.STATE:\n        if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {\n          this.value = (this.states.includes(state));\n        } else {\n          this.value = this.states.includes(state) ? 1.0 : 0.0;\n        }\n        break;\n      default:\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);\n    }\n  }\n}\n\nclass Component {\n  /**\n   * @param {Object} componentId - Id of the component\n   * @param {Object} componentDescription - Description of the component to be created\n   */\n  constructor(componentId, componentDescription) {\n    if (!componentId\n     || !componentDescription\n     || !componentDescription.visualResponses\n     || !componentDescription.gamepadIndices\n     || Object.keys(componentDescription.gamepadIndices).length === 0) {\n      throw new Error('Invalid arguments supplied');\n    }\n\n    this.id = componentId;\n    this.type = componentDescription.type;\n    this.rootNodeName = componentDescription.rootNodeName;\n    this.touchPointNodeName = componentDescription.touchPointNodeName;\n\n    // Build all the visual responses for this component\n    this.visualResponses = {};\n    Object.keys(componentDescription.visualResponses).forEach((responseName) => {\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);\n      this.visualResponses[responseName] = visualResponse;\n    });\n\n    // Set default values\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);\n\n    this.values = {\n      state: Constants.ComponentState.DEFAULT,\n      button: (this.gamepadIndices.button !== undefined) ? 0 : undefined,\n      xAxis: (this.gamepadIndices.xAxis !== undefined) ? 0 : undefined,\n      yAxis: (this.gamepadIndices.yAxis !== undefined) ? 0 : undefined\n    };\n  }\n\n  get data() {\n    const data = { id: this.id, ...this.values };\n    return data;\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\n   */\n  updateFromGamepad(gamepad) {\n    // Set the state to default before processing other data sources\n    this.values.state = Constants.ComponentState.DEFAULT;\n\n    // Get and normalize button\n    if (this.gamepadIndices.button !== undefined\n        && gamepad.buttons.length > this.gamepadIndices.button) {\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];\n      this.values.button = gamepadButton.value;\n      this.values.button = (this.values.button < 0) ? 0 : this.values.button;\n      this.values.button = (this.values.button > 1) ? 1 : this.values.button;\n\n      // Set the state based on the button\n      if (gamepadButton.pressed || this.values.button === 1) {\n        this.values.state = Constants.ComponentState.PRESSED;\n      } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Get and normalize x axis value\n    if (this.gamepadIndices.xAxis !== undefined\n        && gamepad.axes.length > this.gamepadIndices.xAxis) {\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];\n      this.values.xAxis = (this.values.xAxis < -1) ? -1 : this.values.xAxis;\n      this.values.xAxis = (this.values.xAxis > 1) ? 1 : this.values.xAxis;\n\n      // If the state is still default, check if the xAxis makes it touched\n      if (this.values.state === Constants.ComponentState.DEFAULT\n        && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Get and normalize Y axis value\n    if (this.gamepadIndices.yAxis !== undefined\n        && gamepad.axes.length > this.gamepadIndices.yAxis) {\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];\n      this.values.yAxis = (this.values.yAxis < -1) ? -1 : this.values.yAxis;\n      this.values.yAxis = (this.values.yAxis > 1) ? 1 : this.values.yAxis;\n\n      // If the state is still default, check if the yAxis makes it touched\n      if (this.values.state === Constants.ComponentState.DEFAULT\n        && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {\n        this.values.state = Constants.ComponentState.TOUCHED;\n      }\n    }\n\n    // Update the visual response weights based on the current component data\n    Object.values(this.visualResponses).forEach((visualResponse) => {\n      visualResponse.updateFromComponent(this.values);\n    });\n  }\n}\n\n/**\n  * @description Builds a motion controller with components and visual responses based on the\n  * supplied profile description. Data is polled from the xrInputSource's gamepad.\n  * @author Nell Waliczek / https://github.com/NellWaliczek\n*/\nclass MotionController {\n  /**\n   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around\n   * @param {Object} profile - The best matched profile description for the supplied xrInputSource\n   * @param {Object} assetUrl\n   */\n  constructor(xrInputSource, profile, assetUrl) {\n    if (!xrInputSource) {\n      throw new Error('No xrInputSource supplied');\n    }\n\n    if (!profile) {\n      throw new Error('No profile supplied');\n    }\n\n    this.xrInputSource = xrInputSource;\n    this.assetUrl = assetUrl;\n    this.id = profile.profileId;\n\n    // Build child components as described in the profile description\n    this.layoutDescription = profile.layouts[xrInputSource.handedness];\n    this.components = {};\n    Object.keys(this.layoutDescription.components).forEach((componentId) => {\n      const componentDescription = this.layoutDescription.components[componentId];\n      this.components[componentId] = new Component(componentId, componentDescription);\n    });\n\n    // Initialize components based on current gamepad state\n    this.updateFromGamepad();\n  }\n\n  get gripSpace() {\n    return this.xrInputSource.gripSpace;\n  }\n\n  get targetRaySpace() {\n    return this.xrInputSource.targetRaySpace;\n  }\n\n  /**\n   * @description Returns a subset of component data for simplified debugging\n   */\n  get data() {\n    const data = [];\n    Object.values(this.components).forEach((component) => {\n      data.push(component.data);\n    });\n    return data;\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   */\n  updateFromGamepad() {\n    Object.values(this.components).forEach((component) => {\n      component.updateFromGamepad(this.xrInputSource.gamepad);\n    });\n  }\n}\n\nexport { Constants, MotionController, fetchProfile, fetchProfilesList };\n","import {\n\tMesh,\n\tMeshBasicMaterial,\n\tObject3D,\n\tSphereGeometry,\n} from 'three';\n\nimport { GLTFLoader } from '../loaders/GLTFLoader.js';\n\nimport {\n\tConstants as MotionControllerConstants,\n\tfetchProfile,\n\tMotionController\n} from '../libs/motion-controllers.module.js';\n\nconst DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';\nconst DEFAULT_PROFILE = 'generic-trigger';\n\nclass XRControllerModel extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.motionController = null;\n\t\tthis.envMap = null;\n\n\t}\n\n\tsetEnvironmentMap( envMap ) {\n\n\t\tif ( this.envMap == envMap ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.envMap = envMap;\n\t\tthis.traverse( ( child ) => {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tchild.material.envMap = this.envMap;\n\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Polls data from the XRInputSource and updates the model's components to match\n\t * the real world data\n\t */\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( ! this.motionController ) return;\n\n\t\t// Cause the MotionController to poll the Gamepad for data\n\t\tthis.motionController.updateFromGamepad();\n\n\t\t// Update the 3D model to reflect the button, thumbstick, and touchpad state\n\t\tObject.values( this.motionController.components ).forEach( ( component ) => {\n\n\t\t\t// Update node data based on the visual responses' current states\n\t\t\tObject.values( component.visualResponses ).forEach( ( visualResponse ) => {\n\n\t\t\t\tconst { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;\n\n\t\t\t\t// Skip if the visual response node is not found. No error is needed,\n\t\t\t\t// because it will have been reported at load time.\n\t\t\t\tif ( ! valueNode ) return;\n\n\t\t\t\t// Calculate the new properties based on the weight supplied\n\t\t\t\tif ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY ) {\n\n\t\t\t\t\tvalueNode.visible = value;\n\n\t\t\t\t} else if ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {\n\n\t\t\t\t\tvalueNode.quaternion.slerpQuaternions(\n\t\t\t\t\t\tminNode.quaternion,\n\t\t\t\t\t\tmaxNode.quaternion,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\n\t\t\t\t\tvalueNode.position.lerpVectors(\n\t\t\t\t\t\tminNode.position,\n\t\t\t\t\t\tmaxNode.position,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Walks the model's tree to find the nodes needed to animate the components and\n * saves them to the motionContoller components for use in the frame loop. When\n * touchpads are found, attaches a touch dot to them.\n */\nfunction findNodes( motionController, scene ) {\n\n\t// Loop through the components and find the nodes needed for each components' visual responses\n\tObject.values( motionController.components ).forEach( ( component ) => {\n\n\t\tconst { type, touchPointNodeName, visualResponses } = component;\n\n\t\tif ( type === MotionControllerConstants.ComponentType.TOUCHPAD ) {\n\n\t\t\tcomponent.touchPointNode = scene.getObjectByName( touchPointNodeName );\n\t\t\tif ( component.touchPointNode ) {\n\n\t\t\t\t// Attach a touch dot to the touchpad.\n\t\t\t\tconst sphereGeometry = new SphereGeometry( 0.001 );\n\t\t\t\tconst material = new MeshBasicMaterial( { color: 0x0000FF } );\n\t\t\t\tconst sphere = new Mesh( sphereGeometry, material );\n\t\t\t\tcomponent.touchPointNode.add( sphere );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( `Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Loop through all the visual responses to be applied to this component\n\t\tObject.values( visualResponses ).forEach( ( visualResponse ) => {\n\n\t\t\tconst { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;\n\n\t\t\t// If animating a transform, find the two nodes to be interpolated between.\n\t\t\tif ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {\n\n\t\t\t\tvisualResponse.minNode = scene.getObjectByName( minNodeName );\n\t\t\t\tvisualResponse.maxNode = scene.getObjectByName( maxNodeName );\n\n\t\t\t\t// If the extents cannot be found, skip this animation\n\t\t\t\tif ( ! visualResponse.minNode ) {\n\n\t\t\t\t\tconsole.warn( `Could not find ${minNodeName} in the model` );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! visualResponse.maxNode ) {\n\n\t\t\t\t\tconsole.warn( `Could not find ${maxNodeName} in the model` );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// If the target node cannot be found, skip this animation\n\t\t\tvisualResponse.valueNode = scene.getObjectByName( valueNodeName );\n\t\t\tif ( ! visualResponse.valueNode ) {\n\n\t\t\t\tconsole.warn( `Could not find ${valueNodeName} in the model` );\n\n\t\t\t}\n\n\t\t} );\n\n\t} );\n\n}\n\nfunction addAssetSceneToControllerModel( controllerModel, scene ) {\n\n\t// Find the nodes needed for animation and cache them on the motionController.\n\tfindNodes( controllerModel.motionController, scene );\n\n\t// Apply any environment map that the mesh already has set.\n\tif ( controllerModel.envMap ) {\n\n\t\tscene.traverse( ( child ) => {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tchild.material.envMap = controllerModel.envMap;\n\t\t\t\tchild.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// Add the glTF scene to the controllerModel.\n\tcontrollerModel.add( scene );\n\n}\n\nclass XRControllerModelFactory {\n\n\tconstructor( gltfLoader = null ) {\n\n\t\tthis.gltfLoader = gltfLoader;\n\t\tthis.path = DEFAULT_PROFILES_PATH;\n\t\tthis._assetCache = {};\n\n\t\t// If a GLTFLoader wasn't supplied to the constructor create a new one.\n\t\tif ( ! this.gltfLoader ) {\n\n\t\t\tthis.gltfLoader = new GLTFLoader();\n\n\t\t}\n\n\t}\n\n\tcreateControllerModel( controller ) {\n\n\t\tconst controllerModel = new XRControllerModel();\n\t\tlet scene = null;\n\n\t\tcontroller.addEventListener( 'connected', ( event ) => {\n\n\t\t\tconst xrInputSource = event.data;\n\n\t\t\tif ( xrInputSource.targetRayMode !== 'tracked-pointer' || ! xrInputSource.gamepad ) return;\n\n\t\t\tfetchProfile( xrInputSource, this.path, DEFAULT_PROFILE ).then( ( { profile, assetPath } ) => {\n\n\t\t\t\tcontrollerModel.motionController = new MotionController(\n\t\t\t\t\txrInputSource,\n\t\t\t\t\tprofile,\n\t\t\t\t\tassetPath\n\t\t\t\t);\n\n\t\t\t\tconst cachedAsset = this._assetCache[ controllerModel.motionController.assetUrl ];\n\t\t\t\tif ( cachedAsset ) {\n\n\t\t\t\t\tscene = cachedAsset.scene.clone();\n\n\t\t\t\t\taddAssetSceneToControllerModel( controllerModel, scene );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ! this.gltfLoader ) {\n\n\t\t\t\t\t\tthrow new Error( 'GLTFLoader not set.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.gltfLoader.setPath( '' );\n\t\t\t\t\tthis.gltfLoader.load( controllerModel.motionController.assetUrl, ( asset ) => {\n\n\t\t\t\t\t\tthis._assetCache[ controllerModel.motionController.assetUrl ] = asset;\n\n\t\t\t\t\t\tscene = asset.scene.clone();\n\n\t\t\t\t\t\taddAssetSceneToControllerModel( controllerModel, scene );\n\n\t\t\t\t\t},\n\t\t\t\t\tnull,\n\t\t\t\t\t() => {\n\n\t\t\t\t\t\tthrow new Error( `Asset ${controllerModel.motionController.assetUrl} missing or malformed.` );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} ).catch( ( err ) => {\n\n\t\t\t\tconsole.warn( err );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tcontroller.addEventListener( 'disconnected', () => {\n\n\t\t\tcontrollerModel.motionController = null;\n\t\t\tcontrollerModel.remove( scene );\n\t\t\tscene = null;\n\n\t\t} );\n\n\t\treturn controllerModel;\n\n\t}\n\n}\n\nexport { XRControllerModelFactory };\n","/* eslint-disable */\n// https://github.com/gkjohnson/webxr-sandbox\n\nfunction isTypedArray( arr ) {\n\n\treturn arr.buffer instanceof ArrayBuffer && 'BYTES_PER_ELEMENT' in arr;\n\n}\n\nexport class MaterialReducer {\n\n\tconstructor() {\n\n\t\tconst ignoreKeys = new Set();\n\t\tignoreKeys.add( 'uuid' );\n\n\t\tthis.ignoreKeys = ignoreKeys;\n\t\tthis.shareTextures = true;\n\n\t}\n\n\tareEqual( objectA, objectB ) {\n\n\t\tconst keySet = new Set();\n\t\tconst traverseSet = new Set();\n\t\tconst ignoreKeys = this.ignoreKeys;\n\n\t\tconst traverse = ( a, b ) => {\n\n\t\t\tif ( a === b ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif ( a && b && a instanceof Object && b instanceof Object ) {\n\n\t\t\t\tif ( traverseSet.has( a ) || traverseSet.has( b ) ) {\n\n\t\t\t\t\tthrow new Error( 'MaterialReducer: Material is recursive.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsElement = a instanceof Element;\n\t\t\t\tconst bIsElement = b instanceof Element;\n\t\t\t\tif ( aIsElement || bIsElement ) {\n\n\t\t\t\t\tif ( aIsElement !== bIsElement || ! ( a instanceof Image ) || ! ( b instanceof Image ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\t\t\t\t\treturn a.src === b.src;\n\n\t\t\t\t}\n\n\t\t\t\tif ( a.equals ) {\n\n\t\t\t\t\treturn a.equals( b );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsTypedArray = isTypedArray( a );\n\t\t\t\tconst bIsTypedArray = isTypedArray( b );\n\t\t\t\tif ( aIsTypedArray || bIsTypedArray ) {\n\n\t\t\t\t\tif ( aIsTypedArray !== bIsTypedArray || a.constructor !== b.constructor || a.length !== b.length ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\t\t\t\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.add( a );\n\t\t\t\ttraverseSet.add( b );\n\n\t\t\t\tkeySet.clear();\n\t\t\t\tfor ( const key in a ) {\n\n\t\t\t\t\tif ( ! a.hasOwnProperty( key ) || a[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\t\t\t\tfor ( const key in b ) {\n\n\t\t\t\t\tif ( ! b.hasOwnProperty( key ) || b[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tconst keys = Array.from( keySet.values() );\n\t\t\t\tlet result = true;\n\t\t\t\tfor ( const i in keys ) {\n\n\t\t\t\t\tconst key = keys[ i ];\n\t\t\t\t\tif ( ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = traverse( a[ key ], b[ key ] );\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.delete( a );\n\t\t\t\ttraverseSet.delete( b );\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\treturn traverse( objectA, objectB );\n\n\t}\n\n\tprocess( object ) {\n\n\t\tconst textures = [];\n\t\tconst materials = [];\n\t\tlet replaced = 0;\n\n\t\tconst processMaterial = material => {\n\n\t\t\t// Check if another material matches this one\n\t\t\tlet foundMaterial = null;\n\t\t\tfor ( const i in materials ) {\n\n\t\t\t\tconst otherMaterial = materials[ i ];\n\t\t\t\tif ( this.areEqual( material, otherMaterial ) ) {\n\n\t\t\t\t\tfoundMaterial = otherMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( foundMaterial ) {\n\n\t\t\t\treplaced ++;\n\t\t\t\treturn foundMaterial;\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\tif ( this.shareTextures ) {\n\n\t\t\t\t\t// See if there's another texture that matches the ones on this material\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tif ( ! material.hasOwnProperty( key ) ) continue;\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture && value.image instanceof Image ) {\n\n\t\t\t\t\t\t\tlet foundTexture = null;\n\t\t\t\t\t\t\tfor ( const i in textures ) {\n\n\t\t\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\t\t\tif ( this.areEqual( texture, value ) ) {\n\n\t\t\t\t\t\t\t\t\tfoundTexture = texture;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( foundTexture ) {\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = foundTexture;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t}\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh && c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tmaterial[ i ] = processMaterial( material[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = processMaterial( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn { replaced, retained: materials.length };\n\n\t}\n\n}\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3\n} from 'three';\n\n\nfunction computeTangents( geometry ) {\n\n\tgeometry.computeTangents();\n\tconsole.warn( 'THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.' );\n\n}\n\n/**\n\t * @param  {Array<BufferGeometry>} geometries\n\t * @param  {Boolean} useGroups\n\t * @return {BufferGeometry}\n\t */\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\t// gather .userData\n\n\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeBufferAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeBufferAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\treturn new BufferAttribute( array, itemSize, normalized );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst attrArrays = {};\n\tconst morphAttrsArrays = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t// initialize the arrays\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\n\t\tattrArrays[ name ] = [];\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the attribute arrays\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = attrArrays[ name ];\n\t\t\t\tconst newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// Generate typed arrays from new attribute arrays and update\n\t// the attributeBuffers\n\tconst result = geometry.clone();\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst oldAttribute = geometry.getAttribute( name );\n\n\t\tconst buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\tconst attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\tresult.setAttribute( name, attribute );\n\n\t\t// Update the attribute arrays\n\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\tfor ( let j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\tconst oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\tconst buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\tconst morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry>}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tif ( object.geometry.isBufferGeometry !== true ) {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );\n\t\treturn null;\n\n\t}\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tmaterial,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( material.morphTargets && morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.boneTransform( a, _vA );\n\t\t\tobject.boneTransform( b, _vB );\n\t\t\tobject.boneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group, groupMaterial;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\n\n\nexport {\n\tcomputeTangents,\n\tmergeBufferGeometries,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n};\n","/* eslint-disable */\n// https://github.com/gkjohnson/webxr-sandbox\n\nimport {\n\tBone,\n\tSkinnedMesh,\n\tGroup,\n\tBufferAttribute,\n\tSkeleton,\n\tBox3,\n\tMatrix4,\n\tSphere,\n\tBufferGeometry,\n} from 'three';\nimport * as\tBufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';\n\nconst inverseMatrix = new Matrix4();\nclass ProxySkinnedMesh extends SkinnedMesh {\n\n\tconstructor( geometry, material, meshes ) {\n\n\t\tsuper( geometry, material );\n\t\tthis.proxied = meshes;\n\n\t}\n\n\traycast( ...args ) {\n\n\t\tconst { proxied } = this;\n\t\tfor ( let i = 0, l = proxied.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = proxied[ i ];\n\t\t\tmesh.raycast( ...args );\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t\tconst { geometry, matrixWorld, proxied, frustumCulled } = this;\n\t\tif ( ! geometry.boundingBox ) {\n\n\t\t\tgeometry.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( ! geometry.boundingSphere ) {\n\n\t\t\tgeometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( frustumCulled ) {\n\n\t\t\tconst box = geometry.boundingBox;\n\t\t\tbox.makeEmpty();\n\n\t\t\tfor ( let i = 0, l = proxied.length; i < l; i ++ ) {\n\n\t\t\t\tbox.expandByObject( proxied[ i ] );\n\n\t\t\t}\n\t\t\t// inverseMatrix.copy( matrixWorld ).invert();\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tbox.applyMatrix4( inverseMatrix );\n\t\t\tbox.getBoundingSphere( geometry.boundingSphere );\n\n\t\t}\n\n\t}\n\n}\n\nclass ProxyBone extends Bone {\n\n\tconstructor( proxied ) {\n\n\t\tsuper();\n\t\tthis.proxied = proxied;\n\n\t}\n\n\tupdateMatrixWorld() {\n\n\t\tconst { matrixWorld, proxied } = this;\n\t\tproxied.updateMatrixWorld( true );\n\t\tmatrixWorld.copy( proxied.matrixWorld );\n\n\t}\n\n}\n\nexport class ProxyBatchedMesh extends Group {\n\n\tget visible() {\n\n\t\treturn this.proxied.visible;\n\n\t}\n\n\tset visible( v ) {\n\n\t\tif ( this.proxied ) {\n\n\t\t\tthis.proxied.visible = v;\n\n\t\t}\n\n\t}\n\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tif ( root.parent ) {\n\n\t\t\tthrow new Error( 'ProxyBatchedMesh : Proxied root is not expected to have a parent.' );\n\n\t\t}\n\n\t\t// Set it's parent to this so the matrix world computations\n\t\t// account for this transform.\n\t\troot.parent = this;\n\t\tthis.proxied = root;\n\n\t\t// Find all shared materials\n\t\tconst materialToGeometry = new Map();\n\t\troot.updateMatrixWorld( true );\n\t\troot.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tconst materials = c.material;\n\t\t\t\t\tconst hadIndex = Boolean( c.geometry.index );\n\t\t\t\t\tconst geometry = hadIndex ? c.geometry.clone().toNonIndexed() : c.geometry;\n\t\t\t\t\tconst groups = geometry.groups;\n\t\t\t\t\tconst attributes = geometry.attributes;\n\n\t\t\t\t\t// for every group create a trimmed geometry that includes only the relevant indices\n\t\t\t\t\tgroups.forEach( group => {\n\n\t\t\t\t\t\tconst material = materials[ group.materialIndex ];\n\t\t\t\t\t\tif ( ! materialToGeometry.get( material ) ) {\n\n\t\t\t\t\t\t\tmaterialToGeometry.set( material, [] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// create the trimmed attribute buffers\n\t\t\t\t\t\tconst trimmedGeometry = new BufferGeometry();\n\t\t\t\t\t\tfor ( const name in attributes ) {\n\n\t\t\t\t\t\t\tconst attribute = attributes[ name ];\n\t\t\t\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\t\t\t\tconst trimmedAttribute = new BufferAttribute(\n\t\t\t\t\t\t\t\tattribute.array.slice(\n\t\t\t\t\t\t\t\t\titemSize * group.start,\n\t\t\t\t\t\t\t\t\titemSize * ( group.start + group.count ),\n\t\t\t\t\t\t\t\t),\n\n\t\t\t\t\t\t\t\tattribute.itemSize,\n\t\t\t\t\t\t\t\tattribute.normalized,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\ttrimmedGeometry.setAttribute( name, trimmedAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// create a new index array if it already had one\n\t\t\t\t\t\tif ( hadIndex ) {\n\n\t\t\t\t\t\t\tconst count = trimmedGeometry.attributes.position.count;\n\t\t\t\t\t\t\tconst indexArray = new Array( count )\n\t\t\t\t\t\t\t\t.fill()\n\t\t\t\t\t\t\t\t.map( ( value, index ) => index );\n\t\t\t\t\t\t\ttrimmedGeometry.setIndex( indexArray );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaterialToGeometry.get( material ).push( {\n\t\t\t\t\t\t\tmesh: c,\n\t\t\t\t\t\t\tgeometry: trimmedGeometry,\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst material = c.material;\n\t\t\t\t\tif ( ! materialToGeometry.get( material ) ) {\n\n\t\t\t\t\t\tmaterialToGeometry.set( material, [] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterialToGeometry.get( material ).push( {\n\t\t\t\t\t\tmesh: c,\n\t\t\t\t\t\tgeometry: c.geometry,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Merge all geometries with common materials into a single proxy skinned mesh\n\t\tmaterialToGeometry.forEach( ( infoArray, material ) => {\n\n\t\t\tconst weightCons = infoArray.length > 256 ? Uint16Array : Uint8Array;\n\t\t\tconst bones = [];\n\t\t\tconst geometries = infoArray.map( ( info, index ) => {\n\n\t\t\t\tconst originalGeometry = info.geometry;\n\t\t\t\tconst geometry = new BufferGeometry();\n\t\t\t\tfor ( const name in originalGeometry.attributes ) {\n\n\t\t\t\t\tgeometry.setAttribute( name, originalGeometry.getAttribute( name ) );\n\n\t\t\t\t}\n\t\t\t\tgeometry.setIndex( originalGeometry.getIndex() );\n\t\t\t\tconst count = geometry.attributes.position.count;\n\n\t\t\t\tconst weights = new Uint8Array( count * 4 );\n\t\t\t\tfor ( let i = 0, l = weights.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst i4 = i * 4;\n\t\t\t\t\tweights[ i4 ] = 255;\n\t\t\t\t\tweights[ i4 + 1 ] = 0;\n\t\t\t\t\tweights[ i4 + 2 ] = 0;\n\t\t\t\t\tweights[ i4 + 3 ] = 0;\n\n\t\t\t\t}\n\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t'skinWeight',\n\t\t\t\t\tnew BufferAttribute( weights, 4, true ),\n\t\t\t\t);\n\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t'skinIndex',\n\t\t\t\t\tnew BufferAttribute( new weightCons( count * 4 ).fill( index ), 4 ),\n\t\t\t\t);\n\n\t\t\t\tconst bone = new ProxyBone( info.mesh );\n\t\t\t\tbones.push( bone );\n\n\t\t\t\treturn geometry;\n\n\t\t\t} );\n\n\t\t\tconst skeleton = new Skeleton( bones );\n\t\t\tconst mergedGeometry = BufferGeometryUtils.mergeBufferGeometries( geometries );\n\n\t\t\tconst meshSet = new Set( infoArray.map( c => c.mesh ) );\n\t\t\tconst skinnedMesh = new ProxySkinnedMesh( mergedGeometry, material, Array.from( meshSet ) );\n\t\t\tskinnedMesh.bind( skeleton );\n\n\t\t\tskinnedMesh.add( ...bones );\n\t\t\tthis.add( skinnedMesh );\n\n\t\t} );\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tconst { proxied } = this;\n\t\tif ( proxied.parent && proxied.parent !== this ) {\n\n\t\t\tconsole.warn( 'ProxyBatchedMesh : Proxy mesh is expected to not have parent.' );\n\n\t\t}\n\n\t\tif ( proxied.parent === null ) {\n\n\t\t\tproxied.parent = this;\n\n\t\t}\n\t\tthis.updateWorldMatrix( false, false );\n\t\tproxied.updateMatrixWorld( ...args );\n\t\treturn super.updateMatrixWorld( ...args );\n\n\t}\n\n}\n","import {\n\tWebGLRenderer,\n\tPerspectiveCamera,\n\tColor,\n\tScene,\n\tDirectionalLight,\n\tAmbientLight,\n\tsRGBEncoding,\n\tGroup,\n\tRaycaster,\n\tVector4,\n\tMesh,\n\tSphereBufferGeometry,\n\tMeshBasicMaterial,\n\tTorusBufferGeometry,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tLineBasicMaterial,\n\tAdditiveBlending,\n\tLine,\n\tRingBufferGeometry,\n\tPCFSoftShadowMap,\n\tVector3,\n\tQuaternion,\n\tGridHelper,\n\tBox3,\n\tPlaneBufferGeometry,\n\tShadowMaterial,\n\tMeshPhongMaterial,\n\tBufferAttribute,\n} from 'three';\nimport {\n\tGUI,\n} from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { VRButton } from 'three/examples/jsm/webxr/VRButton.js';\nimport { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory.js';\nimport { mat4 } from 'gl-matrix';\nimport {\n\tSolver,\n\tWorkerSolver,\n\tLink,\n\tJoint,\n\tIKRootsHelper,\n\tsetUrdfFromIK,\n} from '../src/index.js';\nimport {\n\tloadATHLETE,\n\tloadRobonaut,\n\tloadStaubli,\n\tloadCuriosity,\n} from './loadModels.js';\nimport {\n\tMaterialReducer\n} from './lib/MaterialReducer.js';\nimport {\n\tProxyBatchedMesh\n} from './lib/ProxyBatchedMesh.js';\n\n\nconst params = {\n\tshadows: true,\n\tliveRaycasting: true,\n\tscale: 1,\n\tsolve: true,\n\tdisplayIk: false,\n\tdisplayGoals: true,\n\tmodel: 'ATHLETE',\n\twebworker: true,\n};\n\nconst solverOptions = {\n\tuseSVD: false,\n\tmaxIterations: 3,\n\tdivergeThreshold: 0.05,\n\tstallThreshold: 1e-4,\n\ttranslationErrorClamp: 0.25,\n\trotationErrorClamp: 0.25,\n\ttranslationConvergeThreshold: 1e-3,\n\trotationConvergeThreshold: 1e-5,\n\trestPoseFactor: 0.025,\n};\n\nconst goalToLinkMap = new Map();\nconst linkToGoalMap = new Map();\nconst goals = [];\nconst goalIcons = [];\nlet selectedGoalIndex = - 1;\n\nlet loadId = 0;\nlet gui;\nlet renderer, scene, camera, workspace, controller, controllerGrip, ground, directionalLight;\nlet intersectRing, hitSphere, targetObject;\nlet solver, ikHelper, drawThroughIkHelper, ikRoot, urdfRoot, urdfProxy;\nconst tempPos = new Vector3();\nconst tempQuat = new Quaternion();\nconst raycaster = new Raycaster();\n\ninit();\nrebuildGUI();\nloadModel( loadATHLETE() );\n\nfunction init() {\n\n\t// init renderer\n\trenderer = new WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.shadowMap.enabled = true;\n\trenderer.shadowMap.type = PCFSoftShadowMap;\n\trenderer.outputEncoding = sRGBEncoding;\n\tdocument.body.appendChild( renderer.domElement );\n\n\tscene = new Scene();\n\tscene.background = new Color( 0x131619 );\n\n\tworkspace = new Group();\n\tworkspace.position.z = 3;\n\tscene.add( workspace );\n\n\tcamera = new PerspectiveCamera( 50, window.innerWidth / window.innerHeight );\n\tworkspace.add( camera );\n\n\tdirectionalLight = new DirectionalLight();\n\tdirectionalLight.position.set( 5, 30, 15 );\n\tdirectionalLight.castShadow = true;\n\tdirectionalLight.shadow.mapSize.set( 2048, 2048 );\n\tscene.add( directionalLight );\n\n\tconst ambientLight = new AmbientLight( 0x263238, 1 );\n\tscene.add( ambientLight );\n\n\tconst grid = new GridHelper( 10, 10, 0xffffff, 0xffffff );\n\tgrid.material.transparent = true;\n\tgrid.material.opacity = 0.1;\n\tgrid.material.depthWrite = false;\n\tscene.add( grid );\n\n\tground = new Mesh(\n\t\tnew PlaneBufferGeometry(),\n\t\tnew ShadowMaterial( {\n\n\t\t\tcolor: 0,\n\t\t\topacity: 0.25,\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false,\n\n\t\t} ),\n\t);\n\tground.receiveShadow = true;\n\tground.scale.setScalar( 30 );\n\tground.rotation.x = - Math.PI / 2;\n\tground.renderOrder = 1;\n\tscene.add( ground );\n\n\ttargetObject = new Group();\n\ttargetObject.position.set( 0, 1, 1 );\n\tscene.add( targetObject );\n\n\twindow.addEventListener( 'resize', onResize );\n\n\t// widgets\n\tconst whiteMat = new MeshBasicMaterial( { color: 0xffffff } );\n\tintersectRing = new Mesh( new TorusBufferGeometry( 0.25, 0.02, 16, 100 ), whiteMat );\n\tintersectRing.rotation.x = Math.PI / 2;\n\tintersectRing.visible = false;\n\tscene.add( intersectRing );\n\n\thitSphere = new Mesh( new SphereBufferGeometry( 0.005, 50, 50 ), whiteMat );\n\tscene.add( hitSphere );\n\n\t// vr\n\trenderer.xr.enabled = true;\n\trenderer.setAnimationLoop( render );\n\tdocument.body.appendChild( VRButton.createButton( renderer ) );\n\n\t// vr controllers\n\tcontroller = renderer.xr.getController( 0 );\n\tcontroller.addEventListener( 'connected', function ( event ) {\n\n\t\tthis.add( buildController( event.data ) );\n\n\t} );\n\tcontroller.addEventListener( 'disconnected', function () {\n\n\t\tthis.remove( this.children[ 0 ] );\n\n\t} );\n\tworkspace.add( controller );\n\n\tconst startPos = new Vector3();\n\tconst endPos = new Vector3();\n\tlet startTime = - 1;\n\tcontroller.addEventListener( 'selectend', () => {\n\n\t\tif ( selectedGoalIndex !== - 1 ) {\n\n\t\t\tconst goal = goals[ selectedGoalIndex ];\n\t\t\tconst ikLink = goalToLinkMap.get( goal );\n\t\t\tif ( ikLink ) {\n\n\t\t\t\tikLink.updateMatrixWorld();\n\n\t\t\t\tikLink.attachChild( goal );\n\t\t\t\tgoal.setPosition( ...goal.originalPosition );\n\t\t\t\tgoal.setQuaternion( ...goal.originalQuaternion );\n\t\t\t\tikLink.detachChild( goal );\n\n\t\t\t\ttargetObject.position.set( ...goal.position );\n\t\t\t\ttargetObject.quaternion.set( ...goal.quaternion );\n\n\t\t\t}\n\n\t\t\tendPos.set( ...goal.position );\n\t\t\tif ( startPos.distanceTo( endPos ) < 1e-2 / params.scale && window.performance.now() - startTime < 500.0 ) {\n\n\t\t\t\tdeleteGoal( goal );\n\n\t\t\t}\n\n\t\t\tcontroller.remove( targetObject );\n\t\t\tselectedGoalIndex = - 1;\n\n\t\t}\n\n\t} );\n\n\tcontroller.addEventListener( 'selectstart', () => {\n\n\t\tif ( ! urdfRoot ) return;\n\n\t\tconst { ikLink, result } = raycast();\n\n\t\tstartPos.setScalar( Infinity );\n\t\tif ( ikLink === null ) {\n\n\t\t\tlet goalIndex = - 1;\n\t\t\tif ( result ) {\n\n\t\t\t\tgoalIndex = goalIcons.indexOf( result.object.parent );\n\n\t\t\t}\n\n\t\t\tselectedGoalIndex = goalIndex;\n\n\t\t\tif ( goalIndex !== - 1 ) {\n\n\t\t\t\tconst goal = goals[ goalIndex ];\n\t\t\t\ttargetObject.position.set( ...goal.position );\n\t\t\t\ttargetObject.quaternion.set( ...goal.quaternion );\n\t\t\t\tcontroller.attach( targetObject );\n\n\t\t\t\tstartPos.set( ...goal.position );\n\t\t\t\tstartTime = window.performance.now();\n\n\t\t\t} else if ( goalIndex === - 1 && intersectRing.visible ) {\n\n\t\t\t\tworkspace.position\n\t\t\t\t\t.copy( intersectRing.position )\n\t\t\t\t\t.addScaledVector( controller.position, - 1.0 / params.scale );\n\t\t\t\tworkspace.position.y = 0;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( linkToGoalMap.has( ikLink ) ) {\n\n\t\t\tconst goal = linkToGoalMap.get( ikLink );\n\t\t\tdeleteGoal( goal );\n\n\t\t}\n\n\t\t// normal in world space\n\t\tconst norm4 = new Vector4();\n\t\tnorm4.copy( result.face.normal );\n\t\tnorm4.w = 0;\n\t\tnorm4.applyMatrix4( result.object.matrixWorld );\n\n\t\t// create look matrix\n\t\tconst lookMat = mat4.create();\n\t\tconst eyeVec = [ 0, 0, 0 ];\n\t\tconst posVec = norm4.toArray();\n\t\tlet upVec = [ 0, 1, 0 ];\n\t\tif ( Math.abs( posVec[ 1 ] ) > 0.9 ) {\n\n\t\t\tupVec = [ 0, 0, 1 ];\n\n\t\t}\n\n\t\tmat4.targetTo( lookMat, eyeVec, posVec, upVec );\n\n\t\t// The joint that's positioned at the surface of the mesh\n\t\tconst rootGoalJoint = new Joint();\n\t\trootGoalJoint.name = 'GoalRootJoint-' + ikLink.name;\n\t\trootGoalJoint.setPosition(\n\t\t\tresult.point.x,\n\t\t\tresult.point.y,\n\t\t\tresult.point.z,\n\t\t);\n\t\tmat4.getRotation( rootGoalJoint.quaternion, lookMat );\n\n\t\tconst goalLink = new Link();\n\t\trootGoalJoint.addChild( goalLink );\n\n\t\tconst goalJoint = new Joint();\n\t\trootGoalJoint.name = 'GoalJoint-' + ikLink.name;\n\t\tikLink.getWorldPosition( goalJoint.position );\n\t\tikLink.getWorldQuaternion( goalJoint.quaternion );\n\t\tgoalJoint.setMatrixNeedsUpdate();\n\n\t\tgoalLink.attachChild( goalJoint );\n\t\tgoalJoint.makeClosure( ikLink );\n\n\t\t// save the relative position\n\t\tikLink.attachChild( rootGoalJoint );\n\t\trootGoalJoint.originalPosition = rootGoalJoint.position.slice();\n\t\trootGoalJoint.originalQuaternion = rootGoalJoint.quaternion.slice();\n\t\tikLink.detachChild( rootGoalJoint );\n\n\t\t// update the solver\n\t\tsolver.updateStructure();\n\t\tikHelper.updateStructure();\n\t\tdrawThroughIkHelper.updateStructure();\n\n\t\ttargetObject.position.set( ...rootGoalJoint.position );\n\t\ttargetObject.quaternion.set( ...rootGoalJoint.quaternion );\n\t\tcontroller.attach( targetObject );\n\n\t\tgoalToLinkMap.set( rootGoalJoint, ikLink );\n\t\tlinkToGoalMap.set( ikLink, rootGoalJoint );\n\t\tgoals.push( rootGoalJoint );\n\t\tselectedGoalIndex = goals.length - 1;\n\n\t} );\n\n\tconst controllerModelFactory = new XRControllerModelFactory();\n\tcontrollerGrip = renderer.xr.getControllerGrip( 0 );\n\tcontrollerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );\n\tworkspace.add( controllerGrip );\n\n}\n\nfunction deleteGoal( goal ) {\n\n\tconst index = goals.indexOf( goal );\n\tconst goalToRemove = goals[ index ];\n\tgoalToRemove.traverse( c => {\n\n\t\tif ( c.isClosure ) {\n\n\t\t\tc.removeChild( c.child );\n\n\t\t}\n\n\t} );\n\n\tgoals.splice( index, 1 );\n\n\tconst link = goalToLinkMap.get( goalToRemove );\n\tgoalToLinkMap.delete( goalToRemove );\n\tlinkToGoalMap.delete( link );\n\n\tsolver.updateStructure();\n\tikHelper.updateStructure();\n\tdrawThroughIkHelper.updateStructure();\n\n}\n\nfunction onResize() {\n\n\tconst w = window.innerWidth;\n\tconst h = window.innerHeight;\n\tconst aspect = w / h;\n\n\trenderer.setSize( w, h );\n\n\tcamera.aspect = aspect;\n\tcamera.updateProjectionMatrix();\n\n\tif ( ikHelper ) {\n\n\t\tikHelper.setResolution( window.innerWidth, window.innerHeight );\n\t\tdrawThroughIkHelper.setResolution( window.innerWidth, window.innerHeight );\n\n\t}\n\n}\n\nfunction buildController( data ) {\n\n\tlet geometry, material;\n\n\tswitch ( data.targetRayMode ) {\n\n\t\tcase 'tracked-pointer':\n\n\t\t\tgeometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );\n\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );\n\n\t\t\tmaterial = new LineBasicMaterial( {\n\t\t\t\tvertexColors: true,\n\t\t\t\tblending: AdditiveBlending,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttransparent: true,\n\t\t\t} );\n\n\t\t\treturn new Line( geometry, material );\n\n\t\tcase 'gaze':\n\n\t\t\tgeometry = new RingBufferGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );\n\t\t\tmaterial = new MeshBasicMaterial( { opacity: 0.5, transparent: true } );\n\t\t\treturn new Mesh( geometry, material );\n\n\t}\n\n}\n\nfunction raycast( justGoals = false ) {\n\n\tcontroller.updateMatrixWorld();\n\traycaster.ray.origin.set( 0, 0, 0 ).applyMatrix4( controller.matrixWorld );\n\traycaster.ray.direction.set( 0, 0, - 1 ).transformDirection( controller.matrixWorld );\n\n\tlet results;\n\tconst intersectGoals = [ ...goalIcons ];\n\tintersectGoals.length = intersectGoals.length < goals.length ? intersectGoals.length : goals.length;\n\n\tresults = raycaster.intersectObjects( intersectGoals, true );\n\tif ( results.length !== 0 ) {\n\n\t\treturn { ikLink: null, result: results[ 0 ] };\n\n\t}\n\n\tif ( justGoals ) {\n\n\t\treturn { ikLink: null, result: null };\n\n\t}\n\n\tresults = raycaster.intersectObjects( [ urdfRoot ], true );\n\tif ( results.length === 0 ) {\n\n\t\treturn { ikLink: null, result: null };\n\n\t}\n\n\tconst result = results[ 0 ];\n\n\tlet nearestLink = null;\n\tlet ikLink = null;\n\tresult.object.traverseAncestors( p => {\n\n\t\tif ( nearestLink === null && p.isURDFLink ) {\n\n\t\t\tnearestLink = p;\n\t\t\tikRoot.traverse( c => {\n\n\t\t\t\tif ( c.name === nearestLink.name ) {\n\n\t\t\t\t\tikLink = c;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t} );\n\n\treturn { ikLink, result };\n\n}\n\nfunction render() {\n\n\tconst allGoals = goals;\n\tconst selectedGoal = allGoals[ selectedGoalIndex ];\n\tif ( ikRoot ) {\n\n\t\tintersectRing.visible = false;\n\t\thitSphere.visible = false;\n\t\tif ( selectedGoal ) {\n\n\t\t\ttargetObject.getWorldPosition( tempPos );\n\t\t\ttargetObject.getWorldQuaternion( tempQuat );\n\n\t\t\tselectedGoal.setPosition( tempPos.x, tempPos.y, tempPos.z );\n\t\t\tselectedGoal.setQuaternion( tempQuat.x, tempQuat.y, tempQuat.z, tempQuat.w );\n\n\t\t} else {\n\n\t\t\tconst { result } = raycast( ! params.liveRaycasting );\n\t\t\tconst lineRay = controller.children[ 0 ];\n\t\t\tif ( lineRay ) {\n\n\t\t\t\tlineRay.scale.setScalar( 1, 1, 1 );\n\n\t\t\t}\n\n\t\t\tif ( result === null ) {\n\n\t\t\t\traycaster.ray.origin.set( 0, 0, 0 ).applyMatrix4( controller.matrixWorld );\n\t\t\t\traycaster.ray.direction.set( 0, 0, - 1 ).transformDirection( controller.matrixWorld );\n\t\t\t\tconst hit = raycaster.intersectObject( ground )[ 0 ];\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersectRing.visible = true;\n\t\t\t\t\tintersectRing.position.copy( hit.point );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( lineRay ) {\n\n\t\t\t\t\tlineRay.scale.setScalar( result.distance * params.scale );\n\n\t\t\t\t}\n\n\t\t\t\thitSphere.position.copy( result.point );\n\t\t\t\thitSphere.visible = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( params.solve ) {\n\n\t\t\tif ( solver instanceof WorkerSolver ) {\n\n\t\t\t\tsolver.updateFrameState( ...allGoals );\n\t\t\t\tsolver.updateSolverSettings( solverOptions );\n\n\t\t\t\tif ( ! solver.running ) {\n\n\t\t\t\t\tsolver.solve();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tObject.assign( solver, solverOptions );\n\t\t\t\tsolver.solve();\n\n\t\t\t}\n\n\t\t\tsetUrdfFromIK( urdfRoot, ikRoot );\n\n\t\t}\n\n\t\t// IKHelpers can have a lot of matrices to update so remove it from\n\t\t// the scene when not in use for performance.\n\t\tif ( ! params.displayIk && ikHelper.parent ) {\n\n\t\t\tscene.remove( ikHelper );\n\t\t\tscene.remove( drawThroughIkHelper );\n\n\t\t} else if ( params.displayIk && ! ikHelper.parent ) {\n\n\t\t\tscene.add( ikHelper );\n\t\t\tscene.add( drawThroughIkHelper );\n\n\t\t}\n\n\t}\n\n\twhile ( goalIcons.length < allGoals.length ) {\n\n\t\tconst color = new Color( 0xffca28 ).convertSRGBToLinear();\n\t\tconst group = new Group();\n\t\tconst mesh = new Mesh(\n\t\t\tnew SphereBufferGeometry( 0.01, 30, 30 ),\n\t\t\tnew MeshBasicMaterial( { color } ),\n\t\t);\n\t\tconst mesh2 = new Mesh(\n\t\t\tnew SphereBufferGeometry( 0.01, 30, 30 ),\n\t\t\tnew MeshBasicMaterial( {\n\t\t\t\tcolor,\n\t\t\t\topacity: 0.4,\n\t\t\t\ttransparent: true,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tdepthTest: false,\n\t\t\t} ),\n\t\t);\n\n\t\tgroup.add( mesh, mesh2 );\n\t\tscene.add( group );\n\t\tgoalIcons.push( group );\n\n\t}\n\n\tgoalIcons.forEach( g => {\n\n\t\tg.visible = false;\n\t\tg.scale.setScalar( 1 / params.scale );\n\n\t} );\n\tallGoals.forEach( ( g, i ) => {\n\n\t\tgoalIcons[ i ].position.set( ...g.position );\n\t\tgoalIcons[ i ].quaternion.set( ...g.quaternion );\n\t\tgoalIcons[ i ].visible = params.displayGoals;\n\n\t} );\n\n\tintersectRing.scale.setScalar( 1 / params.scale );\n\thitSphere.scale.setScalar( 1 / params.scale );\n\tworkspace.scale.setScalar( 1 / params.scale );\n\n\tdirectionalLight.castShadow = params.shadows;\n\trenderer.render( scene, camera );\n\n}\n\nfunction rebuildGUI() {\n\n\tif ( gui ) {\n\n\t\tgui.destroy();\n\n\t}\n\n\tif ( ! ikRoot ) return;\n\n\tgui = new GUI();\n\tgui.width = 350;\n\n\tgui.add( params, 'model', [ 'ATHLETE', 'Robonaut', 'Curiosity', 'Staubli' ] ).onChange( value => {\n\n\t\tlet promise = null;\n\t\tswitch ( value ) {\n\n\t\t\tcase 'ATHLETE':\n\t\t\t\tpromise = loadATHLETE();\n\t\t\t\tbreak;\n\n\t\t\tcase 'Robonaut':\n\t\t\t\tpromise = loadRobonaut();\n\t\t\t\tbreak;\n\n\t\t\tcase 'Curiosity':\n\t\t\t\tpromise = loadCuriosity();\n\t\t\t\tbreak;\n\n\t\t\tcase 'Staubli':\n\t\t\t\tpromise = loadStaubli();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tloadModel( promise );\n\n\t} );\n\tgui.add( params, 'scale', 0.1, 4, 0.01 );\n\tgui.add( params, 'shadows' );\n\tgui.add( params, 'liveRaycasting' );\n\tgui.add( params, 'displayGoals' ).name( 'display goals' );\n\tgui.add( params, 'displayIk' ).name( 'display ik chains' );\n\tgui.add( params, 'webworker' ).onChange( v => {\n\n\t\tif ( v ) {\n\n\t\t\tsolver = new WorkerSolver( solver.roots );\n\n\t\t} else {\n\n\t\t\tsolver.dispose();\n\t\t\tsolver = new Solver( solver.roots );\n\n\t\t}\n\n\t} );\n\tgui.add( { reset: () => {\n\n\t\tlet promise = null;\n\t\tswitch ( params.model ) {\n\n\t\t\tcase 'ATHLETE':\n\t\t\t\tpromise = loadATHLETE();\n\t\t\t\tbreak;\n\n\t\t\tcase 'Robonaut':\n\t\t\t\tpromise = loadRobonaut();\n\t\t\t\tbreak;\n\n\t\t\tcase 'Curiosity':\n\t\t\t\tpromise = loadCuriosity();\n\t\t\t\tbreak;\n\n\t\t\tcase 'Staubli':\n\t\t\t\tpromise = loadStaubli();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tloadModel( promise );\n\n\t} }, 'reset' );\n\n\tconst solveFolder = gui.addFolder( 'solver' );\n\tsolveFolder.add( params, 'solve' ).onChange( v => {\n\n\t\tif ( ! v && solver instanceof WorkerSolver ) {\n\n\t\t\tsolver.stop();\n\n\t\t}\n\n\t} );\n\n\tsolveFolder.add( solverOptions, 'useSVD' );\n\tsolveFolder.add( solverOptions, 'maxIterations' ).min( 1 ).max( 10 ).step( 1 ).listen();\n\tsolveFolder.add( solverOptions, 'divergeThreshold' ).min( 0 ).max( 0.5 ).step( 1e-2 ).listen();\n\tsolveFolder.add( solverOptions, 'stallThreshold' ).min( 0 ).max( 0.01 ).step( 1e-4 ).listen();\n\tsolveFolder.add( solverOptions, 'translationErrorClamp' ).min( 1e-2 ).max( 1 ).listen();\n\tsolveFolder.add( solverOptions, 'rotationErrorClamp' ).min( 1e-2 ).max( 1 ).listen();\n\tsolveFolder.add( solverOptions, 'translationConvergeThreshold' ).min( 1e-3 ).max( 1e-1 ).listen();\n\tsolveFolder.add( solverOptions, 'rotationConvergeThreshold' ).min( 1e-5 ).max( 1e-2 ).listen();\n\tsolveFolder.add( solverOptions, 'restPoseFactor' ).min( 0 ).max( 0.25 ).step( 1e-2 ).listen();\n\tsolveFolder.open();\n\n}\n\nfunction dispose( c ) {\n\n\tif ( c.geometry ) {\n\n\t\tc.geometry.dispose();\n\n\t}\n\n\tif ( c.material ) {\n\n\t\tfunction disposeMaterial( material ) {\n\n\t\t\tmaterial.dispose();\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tif ( material[ key ] && material[ key ].isTexture ) {\n\n\t\t\t\t\tmaterial[ key ].dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\tc.material.forEach( disposeMaterial );\n\n\t\t} else {\n\n\t\t\tdisposeMaterial( c.material );\n\n\t\t}\n\n\n\t}\n\n}\n\nfunction loadModel( promise ) {\n\n\tif ( urdfRoot ) {\n\n\t\turdfRoot.traverse( dispose );\n\t\tdrawThroughIkHelper.traverse( dispose );\n\t\tikHelper.traverse( dispose );\n\t\turdfProxy.traverse( dispose );\n\n\t\tscene.remove( urdfRoot, drawThroughIkHelper, ikHelper, urdfProxy );\n\n\t}\n\n\tikRoot = null;\n\turdfRoot = null;\n\tikHelper = null;\n\tdrawThroughIkHelper = null;\n\tgoals.length = 0;\n\tgoalToLinkMap.clear();\n\tlinkToGoalMap.clear();\n\tselectedGoalIndex = - 1;\n\n\tloadId ++;\n\tconst thisLoadId = loadId;\n\tpromise\n\t\t.then( ( { goalMap, urdf, ik, helperScale = 1 } ) => {\n\n\t\t\tif ( loadId !== thisLoadId ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\turdf.traverse( c => {\n\n\t\t\t\tc.castShadow = true;\n\t\t\t\tc.receiveShadow = true;\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tfunction matToPhong( m ) {\n\n\t\t\t\t\t\treturn new MeshPhongMaterial( {\n\t\t\t\t\t\t\tmap: m.map,\n\t\t\t\t\t\t\tcolor: m.color,\n\t\t\t\t\t\t\tnormalMap: m.normalMap,\n\t\t\t\t\t\t\tnormalMapType: m.normalMapType,\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\t\tc.material = c.material.map( matToPhong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tc.material = matToPhong( c.material );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// remove redundant materials and textures\n\t\t\tconst reducer = new MaterialReducer();\n\t\t\treducer.process( urdf );\n\n\t\t\turdf.traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tc.geometry.deleteAttribute( 'color' );\n\t\t\t\t\tif ( c.geometry.index ) {\n\n\t\t\t\t\t\tc.geometry.toNonIndexed();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( c.geometry.attributes.uv && ! c.material.map ) {\n\n\t\t\t\t\t\tc.geometry.deleteAttribute( 'uv' );\n\n\t\t\t\t\t} else if ( ! c.geometry.attributes.uv && c.material.map ) {\n\n\t\t\t\t\t\tconst count = c.geometry.attributes.position.count;\n\t\t\t\t\t\tc.geometry.setAttribute(\n\t\t\t\t\t\t\t'uv',\n\t\t\t\t\t\t\tnew BufferAttribute(\n\t\t\t\t\t\t\t\tnew Float32Array( count * 2 ),\n\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\t\t\turdfProxy = new ProxyBatchedMesh( urdf );\n\t\t\turdfProxy.children.forEach( sm => {\n\n\t\t\t\tsm.castShadow = true;\n\t\t\t\tsm.receiveShadow = true;\n\t\t\t\tsm.material.skinning = true;\n\n\t\t\t} );\n\n\t\t\tsetUrdfFromIK( urdf, ik );\n\n\t\t\tconst box = new Box3();\n\t\t\turdf.updateMatrixWorld( true );\n\t\t\tbox.setFromObject( urdf );\n\t\t\turdf.position.y -= box.min.y;\n\t\t\tik.position[ 1 ] -= box.min.y;\n\t\t\tik.setMatrixNeedsUpdate();\n\n\n\t\t\tgoalMap.forEach( ( link, goal ) => {\n\n\t\t\t\tgoal.position[ 1 ] -= box.min.y;\n\t\t\t\tgoal.setMatrixNeedsUpdate();\n\n\t\t\t} );\n\n\t\t\tik.updateMatrixWorld( true );\n\n\t\t\t// create the helper\n\t\t\tikHelper = new IKRootsHelper( ik );\n\t\t\tikHelper.setJointScale( helperScale );\n\t\t\tikHelper.setResolution( window.innerWidth, window.innerHeight );\n\t\t\tikHelper.color.set( 0xe91e63 ).convertSRGBToLinear();\n\t\t\tikHelper.setColor( ikHelper.color );\n\n\t\t\tdrawThroughIkHelper = new IKRootsHelper( ik );\n\t\t\tdrawThroughIkHelper.setJointScale( helperScale );\n\t\t\tdrawThroughIkHelper.setResolution( window.innerWidth, window.innerHeight );\n\t\t\tdrawThroughIkHelper.color.set( 0xe91e63 ).convertSRGBToLinear();\n\t\t\tdrawThroughIkHelper.setColor( drawThroughIkHelper.color );\n\t\t\tdrawThroughIkHelper.setDrawThrough( true );\n\n\t\t\tscene.add( urdfProxy, ikHelper, drawThroughIkHelper );\n\n\t\t\tconst loadedGoals = [];\n\t\t\tgoalMap.forEach( ( link, goal ) => {\n\n\t\t\t\tloadedGoals.push( goal );\n\t\t\t\tgoalToLinkMap.set( goal, link );\n\t\t\t\tlinkToGoalMap.set( link, goal );\n\n\t\t\t} );\n\n\t\t\tsolver = params.webworker ? new WorkerSolver( ik ) : new Solver( ik );\n\n\t\t\tselectedGoalIndex = - 1;\n\n\t\t\tloadedGoals.forEach( g => {\n\n\t\t\t\tg.originalPosition = [ 0, 0, 0 ];\n\t\t\t\tg.originalQuaternion = [ 0, 0, 0, 1 ];\n\n\t\t\t} );\n\n\t\t\tikRoot = ik;\n\t\t\turdfRoot = urdf;\n\t\t\tgoals.push( ...loadedGoals );\n\n\t\t\trebuildGUI();\n\n\t\t} );\n\n}\n"],"names":["$2e81c5a0f10917ae$export$da3cdac99155b982","renderer","options","console","error","button","document","createElement","disableButton","style","display","cursor","left","width","onmouseenter","onmouseleave","onclick","stylizeElement","element","position","bottom","padding","border","borderRadius","background","color","font","textAlign","opacity","outline","zIndex","navigator","id","xr","isSessionSupported","then","supported","currentSession","onSessionStarted","session","addEventListener","onSessionEnded","setSession","textContent","removeEventListener","sessionInit","optionalFeatures","requestSession","end","showEnterVR","xrSessionIsGranted","click","catch","exception","warn","message","window","isSecureContext","href","location","replace","innerHTML","textDecoration","registerSessionGrantedListener","$559434fcc6e6401d$export$aa93f11e7884f0f4","$ilwiq","Loader","manager","super","this","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","$559434fcc6e6401d$var$GLTFMaterialsClearcoatExtension","$559434fcc6e6401d$var$GLTFTextureBasisUExtension","$559434fcc6e6401d$var$GLTFTextureWebPExtension","$559434fcc6e6401d$var$GLTFMaterialsSheenExtension","$559434fcc6e6401d$var$GLTFMaterialsTransmissionExtension","$559434fcc6e6401d$var$GLTFMaterialsVolumeExtension","$559434fcc6e6401d$var$GLTFMaterialsIorExtension","$559434fcc6e6401d$var$GLTFMaterialsSpecularExtension","$559434fcc6e6401d$var$GLTFLightsExtension","$559434fcc6e6401d$var$GLTFMeshoptCompression","load","url","onLoad","onProgress","onError","scope","resourcePath","path","LoaderUtils","extractUrlBase","itemStart","_onError","e","itemError","itemEnd","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","gltf","setDRACOLoader","setDDSLoader","Error","setKTX2Loader","setMeshoptDecoder","callback","indexOf","push","unregister","splice","content","extensions","plugins","decodeText","Uint8Array","$559434fcc6e6401d$var$BINARY_EXTENSION_HEADER_MAGIC","$559434fcc6e6401d$var$EXTENSIONS","KHR_BINARY_GLTF","$559434fcc6e6401d$var$GLTFBinaryExtension","json","JSON","undefined","asset","version","$559434fcc6e6401d$var$GLTFParser","crossOrigin","fileLoader","i","length","plugin","name","extensionsUsed","i1","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","$559434fcc6e6401d$var$GLTFMaterialsUnlitExtension","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","$559434fcc6e6401d$var$GLTFMaterialsPbrSpecularGlossinessExtension","KHR_DRACO_MESH_COMPRESSION","$559434fcc6e6401d$var$GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","$559434fcc6e6401d$var$GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","$559434fcc6e6401d$var$GLTFMeshQuantizationExtension","setExtensions","setPlugins","parseAsync","Promise","resolve","reject","$559434fcc6e6401d$var$GLTFRegistry","objects","get","key","add","object","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_IOR","KHR_MATERIALS_SHEEN","KHR_MATERIALS_SPECULAR","KHR_MATERIALS_TRANSMISSION","KHR_MATERIALS_VOLUME","KHR_TEXTURE_BASISU","EXT_TEXTURE_WEBP","EXT_MESHOPT_COMPRESSION","cache","refs","uses","_markDefs","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","light","_addNodeRef","_loadLight","lightIndex","cacheKey","dependency","lightDef","lights","lightNode","Color","fromArray","range","type","DirectionalLight","target","set","PointLight","distance","SpotLight","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","decay","intensity","createUniqueName","createNodeAttachment","self","_getNodeRef","getMaterialType","MeshBasicMaterial","extendParams","materialParams","materialDef","pending","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","array","baseColorTexture","assignTexture","all","materialIndex","materials","MeshPhysicalMaterial","extendMaterialParams","extension","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","scale","clearcoatNormalScale","Vector2","sheenColor","sheenRoughness","sheen","sheenColorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","transmissionFactor","transmission","transmissionTexture","thickness","thicknessFactor","thicknessTexture","attenuationDistance","colorArray","attenuationColor","ior","specularIntensity","specularFactor","specularTexture","specularColorFactor","specularColor","specularColorTexture","texture","encoding","sRGBEncoding","loadTexture","textureIndex","textureDef","textures","loadTextureImage","source","isSupported","images","textureLoader","uri","handler","getHandler","detectSupport","image","Image","src","onload","onerror","height","loadBufferView","index","bufferView","bufferViews","extensionDef","buffer","getDependency","decoder","ready","res","byteOffset","byteLength","count","stride","byteStride","result","ArrayBuffer","decodeGltfBuffer","mode","filter","$559434fcc6e6401d$var$BINARY_EXTENSION_CHUNK_TYPES","body","headerView","DataView","header","magic","slice","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","preload","decodePrimitive","primitive","bufferViewIndex","gltfAttributeMap","attributes","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","attributeName","threeAttributeName","$559434fcc6e6401d$var$ATTRIBUTES","toLowerCase","attributeName1","accessorDef","accessors","componentType","$559434fcc6e6401d$var$WEBGL_COMPONENT_TYPES","normalized","decodeDracoFile","geometry","attribute","extendTexture","transform","texCoord","offset","rotation","clone","repeat","needsUpdate","$559434fcc6e6401d$var$GLTFMeshStandardSGMaterial","MeshStandardMaterial","params","isGLTFSpecularGlossinessMaterial","specularMapParsFragmentChunk","join","glossinessMapParsFragmentChunk","specularMapFragmentChunk","glossinessMapFragmentChunk","lightPhysicalFragmentChunk","uniforms","specular","value","setHex","glossiness","specularMap","glossinessMap","_extraUniforms","onBeforeCompile","shader","uniformName","fragmentShader","Object","defineProperties","v","defines","USE_SPECULARMAP","USE_GLOSSINESSMAP","USE_UV","metalness","roughness","metalnessMap","roughnessMap","setValues","copy","specularGlossinessParams","pbrSpecularGlossiness","diffuseFactor","diffuseTexture","emissive","glossinessFactor","specularGlossinessTexture","specGlossMapDef","createMaterial","material","fog","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","TangentSpaceNormalMap","normalScale","displacementMap","displacementScale","displacementBias","alphaMap","envMap","envMapIntensity","refractionRatio","$559434fcc6e6401d$var$GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","copySampleValue_","values","valueSize","prototype","beforeStart_","afterEnd_","interpolate_","t0","t","t1","stride2","stride3","td","p","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","$559434fcc6e6401d$var$_q","Quaternion","$559434fcc6e6401d$var$GLTFCubicSplineQuaternionInterpolant","normalize","toArray","$559434fcc6e6401d$var$WEBGL_CONSTANTS","Int8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","$559434fcc6e6401d$var$WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","$559434fcc6e6401d$var$WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","$559434fcc6e6401d$var$WEBGL_TYPE_SIZES","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","$559434fcc6e6401d$var$PATH_PROPERTIES","translation","weights","$559434fcc6e6401d$var$INTERPOLATION","CUBICSPLINE","LINEAR","InterpolateLinear","STEP","InterpolateDiscrete","$559434fcc6e6401d$var$ALPHA_MODES","$559434fcc6e6401d$var$addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","$559434fcc6e6401d$var$assignExtrasToUserData","gltfDef","extras","assign","$559434fcc6e6401d$var$updateMorphTargets","mesh","meshDef","updateMorphTargets","il","morphTargetInfluences","targetNames","morphTargetDictionary","$559434fcc6e6401d$var$createPrimitiveKey","primitiveDef","dracoExtension","geometryKey","indices","$559434fcc6e6401d$var$createAttributesKey","attributesKey","keys","sort","$559434fcc6e6401d$var$getNormalizedComponentScale","constructor","associations","Map","primitiveCache","meshCache","cameraCache","lightCache","sourceCache","textureCache","nodeNamesUsed","createImageBitmap","test","userAgent","ImageBitmapLoader","TextureLoader","setCrossOrigin","_invokeAll","ext","beforeRoot","getDependencies","dependencies","scene","scenes","animations","cameras","afterRoot","skinDefs","skins","meshDefs","meshes","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","camera","ref","updateMappings","original","mappings","child","children","entries","_invokeOne","func","unshift","loadScene","loadNode","loadMesh","loadAccessor","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","buffers","resolveURL","bufferViewDef","accessorIndex","sparse","pendingBufferViews","itemSize","TypedArray","elementBytes","BYTES_PER_ELEMENT","itemBytes","bufferAttribute","ibSlice","floor","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","BufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","sourceIndex","sourceDef","sampler","promise","loadImageSource","flipY","samplers","magFilter","minFilter","wrapS","wrapT","URL","webkitURL","sourceURI1","isObjectURL","blob","Blob","mimeType","createObjectURL","sourceURI","isImageBitmapLoader","imageBitmap","Texture","revokeObjectURL","mapName","mapDef","gltfReference","assignFinalMaterial","useDerivativeTangents","tangent","useVertexColors","useFlatShading","normal","isPoints","uuid","pointsMaterial","PointsMaterial","Material","call","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","vertexColors","flatShading","y","uv2","uv","setAttribute","materialType","materialExtensions","sgExtension","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","doubleSided","side","DoubleSide","alphaMode","transparent","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","emissiveFactor","emissiveTexture","originalName","sanitizedName","PropertyBinding","sanitizeNodeName","loadGeometries","primitives","createDracoPrimitive","$559434fcc6e6401d$var$addPrimitiveAttributes","cached","geometryPromise","BufferGeometry","meshIndex","i5","il4","depthTest","FrontSide","results","geometries","SkinnedMesh","Mesh","skinWeight","normalizeSkinWeights","$559434fcc6e6401d$var$toTrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LineSegments","Line","LineLoop","Points","morphAttributes","i3","il2","group","Group","i4","il3","cameraIndex","cameraDef","PerspectiveCamera","MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","OrthographicCamera","xmag","ymag","skinDef","skinEntry","inverseBindMatrices","accessor","animationIndex","animationDef","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","i6","il5","channels","channel","node","input","parameters","output","inputAccessors","outputAccessors","targets","tracks","inputAccessor","outputAccessor","TypedKeyframeTrack","updateMatrix","matrixAutoUpdate","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","targetName","interpolation","traverse","outputArray","scaled","j","jl","track","createInterpolant","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","AnimationClip","createNodeMesh","o","isMesh","nodeName","meshPromise","forEach","Bone","Object3D","matrix","Matrix4","applyMatrix4","quaternion","has","sceneIndex","sceneDef","nodeIds","$559434fcc6e6401d$var$buildNodeHierarchy","node1","reducedAssociations","reduceAssociations","nodeId","parentObject","pendingJoints","jointNodes","bones","boneInverses","jointNode","mat","bind","Skeleton","matrixWorld","assignAttributeAccessor","gltfAttributeName","accessor1","setIndex","box","Box3","min","max","Vector3","boxScale","multiplyScalar","maxDisplacement","vector","abs","expandByVector","boundingBox","sphere","Sphere","getCenter","center","radius","distanceTo","boundingSphere","$559434fcc6e6401d$var$computeBounds","hasMorphPosition","hasMorphNormal","hasMorphColor","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","i2","il1","pendingAccessor","morphPositions","morphNormals","morphColors","morphTargetsRelative","$559434fcc6e6401d$var$addMorphTargets","drawMode","getIndex","getAttribute","numberOfTriangles","newIndices","getX","newGeometry","$7a8c3c23f3e49c64$export$a002182e51710d39","Handedness","freeze","NONE","LEFT","RIGHT","ComponentState","DEFAULT","TOUCHED","PRESSED","ComponentProperty","BUTTON","X_AXIS","Y_AXIS","STATE","ComponentType","TRIGGER","SQUEEZE","TOUCHPAD","THUMBSTICK","ButtonTouchThreshold","AxisTouchThreshold","VisualResponseProperty","TRANSFORM","VISIBILITY","async","$7a8c3c23f3e49c64$var$fetchJsonFile","response","fetch","ok","statusText","$7a8c3c23f3e49c64$export$665d336fd546fbed","xrInputSource","basePath","defaultProfile","getAssetPath","supportedProfilesList","$7a8c3c23f3e49c64$export$cdc669b4504544b3","match","profiles","some","profileId","supportedProfile","profilePath","deprecated","profile","assetPath","layout","handedness","layouts","$7a8c3c23f3e49c64$var$defaultComponentValues","xAxis","yAxis","state","$7a8c3c23f3e49c64$var$VisualResponse","visualResponseDescription","componentProperty","states","valueNodeName","valueNodeProperty","minNodeName","maxNodeName","updateFromComponent","normalizedXAxis","normalizedYAxis","x","sqrt","theta","atan2","cos","sin","$7a8c3c23f3e49c64$var$normalizeAxes","includes","$7a8c3c23f3e49c64$var$Component","componentId","componentDescription","visualResponses","gamepadIndices","rootNodeName","touchPointNodeName","responseName","visualResponse","updateFromGamepad","gamepad","buttons","gamepadButton","pressed","touched","axes","$7a8c3c23f3e49c64$export$d04f314260fc930a","assetUrl","layoutDescription","components","gripSpace","targetRaySpace","component","$e7e1ee5465c2c699$var$XRControllerModel","motionController","setEnvironmentMap","updateMatrixWorld","force","valueNode","minNode","maxNode","visible","slerpQuaternions","lerpVectors","$e7e1ee5465c2c699$var$addAssetSceneToControllerModel","controllerModel","touchPointNode","getObjectByName","sphereGeometry","SphereGeometry","$e7e1ee5465c2c699$var$findNodes","$e7e1ee5465c2c699$export$100331f925a5e0de","gltfLoader","_assetCache","createControllerModel","controller","event","targetRayMode","cachedAsset","err","$6f8ed3ce661202f2$var$isTypedArray","arr","$6f8ed3ce661202f2$export$c80603c061964928","ignoreKeys","Set","shareTextures","areEqual","objectA","objectB","keySet","traverseSet","a","b","aIsElement","Element","bIsElement","equals","aIsTypedArray","bIsTypedArray","l","clear","hasOwnProperty","Function","key1","from","delete","process","replaced","processMaterial","foundMaterial","otherMaterial","isTexture","foundTexture","c","retained","$5451ea62abbe5f68$export$c4eef4c1c9d34ea9","arrayLength","isInterleavedBufferAttribute","$c7e56af603358dd9$var$inverseMatrix","$c7e56af603358dd9$var$ProxySkinnedMesh","proxied","raycast","args","frustumCulled","makeEmpty","expandByObject","getInverse","getBoundingSphere","$c7e56af603358dd9$var$ProxyBone","$c7e56af603358dd9$export$39dde25234c094a9","root","parent","materialToGeometry","hadIndex","Boolean","toNonIndexed","groups","trimmedGeometry","trimmedAttribute","start","indexArray","fill","infoArray","weightCons","info","originalGeometry","bone","skeleton","mergedGeometry","useGroups","isIndexed","attributesUsed","morphAttributesUsed","attributesCount","size","name2","mergedUserData","addGroup","indexOffset","mergedIndex","mergedAttribute","name1","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","$5451ea62abbe5f68$export$728c051ccdf8a702","meshSet","skinnedMesh","updateWorldMatrix","$ee960c3a73f75e07$var$params","shadows","liveRaycasting","solve","displayIk","displayGoals","model","webworker","$ee960c3a73f75e07$var$solverOptions","useSVD","maxIterations","divergeThreshold","stallThreshold","translationErrorClamp","rotationErrorClamp","translationConvergeThreshold","rotationConvergeThreshold","restPoseFactor","$ee960c3a73f75e07$var$goalToLinkMap","$ee960c3a73f75e07$var$linkToGoalMap","$ee960c3a73f75e07$var$goals","$ee960c3a73f75e07$var$goalIcons","$ee960c3a73f75e07$var$gui","$ee960c3a73f75e07$var$renderer","$ee960c3a73f75e07$var$scene","$ee960c3a73f75e07$var$camera","$ee960c3a73f75e07$var$workspace","$ee960c3a73f75e07$var$controller","$ee960c3a73f75e07$var$controllerGrip","$ee960c3a73f75e07$var$ground","$ee960c3a73f75e07$var$directionalLight","$ee960c3a73f75e07$var$intersectRing","$ee960c3a73f75e07$var$hitSphere","$ee960c3a73f75e07$var$targetObject","$ee960c3a73f75e07$var$solver","$ee960c3a73f75e07$var$ikHelper","$ee960c3a73f75e07$var$drawThroughIkHelper","$ee960c3a73f75e07$var$ikRoot","$ee960c3a73f75e07$var$urdfRoot","$ee960c3a73f75e07$var$urdfProxy","$ee960c3a73f75e07$var$selectedGoalIndex","$ee960c3a73f75e07$var$loadId","$ee960c3a73f75e07$var$tempPos","$ee960c3a73f75e07$var$tempQuat","$ee960c3a73f75e07$var$raycaster","Raycaster","$ee960c3a73f75e07$var$deleteGoal","goal","goalToRemove","isClosure","removeChild","link","updateStructure","$ee960c3a73f75e07$var$onResize","w","innerWidth","h","innerHeight","aspect","setSize","updateProjectionMatrix","setResolution","$ee960c3a73f75e07$var$raycast","justGoals","ray","origin","direction","transformDirection","intersectGoals","intersectObjects","ikLink","nearestLink","traverseAncestors","isURDFLink","$ee960c3a73f75e07$var$render","allGoals","selectedGoal","getWorldPosition","getWorldQuaternion","setPosition","z","setQuaternion","lineRay","setScalar","hit","intersectObject","point","$4CEV9","WorkerSolver","updateFrameState","updateSolverSettings","running","setUrdfFromIK","convertSRGBToLinear","SphereBufferGeometry","mesh2","g","castShadow","render","$ee960c3a73f75e07$var$rebuildGUI","destroy","$jiuw3","GUI","onChange","$7coGQ","loadATHLETE","loadRobonaut","loadCuriosity","loadStaubli","$ee960c3a73f75e07$var$loadModel","roots","dispose","Solver","reset","solveFolder","addFolder","stop","step","listen","open","$ee960c3a73f75e07$var$dispose","disposeMaterial","thisLoadId","goalMap","urdf","ik","helperScale","receiveShadow","matToPhong","m","MeshPhongMaterial","deleteAttribute","sm","skinning","setFromObject","setMatrixNeedsUpdate","IKRootsHelper","setJointScale","setColor","setDrawThrough","loadedGoals","originalPosition","originalQuaternion","WebGLRenderer","antialias","setPixelRatio","devicePixelRatio","shadowMap","enabled","PCFSoftShadowMap","outputEncoding","appendChild","domElement","Scene","shadow","mapSize","ambientLight","AmbientLight","grid","GridHelper","PlaneBufferGeometry","ShadowMaterial","renderOrder","whiteMat","TorusBufferGeometry","setAnimationLoop","createButton","getController","Float32BufferAttribute","blending","AdditiveBlending","RingBufferGeometry","translate","$ee960c3a73f75e07$var$buildController","startPos","endPos","startTime","attachChild","detachChild","performance","now","Infinity","goalIndex","attach","addScaledVector","norm4","Vector4","face","lookMat","$6yEsn","mat4","create","posVec","upVec","targetTo","rootGoalJoint","Joint","getRotation","goalLink","Link","addChild","goalJoint","makeClosure","controllerModelFactory","getControllerGrip","$ee960c3a73f75e07$var$init"],"version":3,"file":"vr.747c8674.js.map"}